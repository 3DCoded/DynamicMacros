{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Klipper Dynamic Macros","text":"<p>Never restart Klipper again for simple macros.</p> <p></p> <p>Klipper Dynamic Macros is an unofficial way to update macros without restarting Klipper, so you can update macros mid-print and see their results live. It also supports extra features that normal GCode Macros don't have.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Recursion</li> <li>Receiving Variables</li> <li>Utility Functions</li> <li>Variables</li> <li>Python</li> <li>Delayed GCode</li> </ul>"},{"location":"#how-normal-macros-work","title":"How Normal Macros Work","text":"<p>Your macros are written in a <code>.cfg</code> file, then included into your <code>printer.cfg</code>. When Klipper restarts, it parses these files and saves the macros internally (you can't change them without restarting Klipper). When a macro is called, the cached code is interpreted and run.</p>"},{"location":"#how-dynamic-macros-work","title":"How Dynamic Macros Work","text":"<p>Your macros are written in a <code>.cfg</code> file, then the relative path to that file is configured in a <code>[dynamicmacros]</code> config section. The config files are read and parsed every time you run the <code>DYNAMIC_MACRO</code> command, allowing you to update macros without restarting Klipper.</p>"},{"location":"#klippy-extras-tutorial","title":"Klippy Extras Tutorial","text":"<p>DynamicMacros also includes a tutorial on writing Klippy extras.</p>"},{"location":"#get-started","title":"Get Started","text":"<p>Follow Setup to get started with Dynamic Macros.</p>"},{"location":"#planned-features","title":"Planned Features","text":"<p>See Development Status for the currently available features, and planned features.</p>"},{"location":"#examples","title":"Examples","text":"<p>See Example Macros for examples of Dynamic Macros.</p>"},{"location":"#more-projects","title":"More Projects","text":"<p>If you like this project, don't forget to give it a star! Also, check out the 3MS, a modular multimaterial system for Klipper!</p>"},{"location":"devstatus/","title":"Development Status","text":""},{"location":"devstatus/#features","title":"Features","text":"<ul> <li>Editing macros without restarting Klipper</li> <li>Accessing printer information from within Dynamic Macros</li> <li>Accessing parameters from within Dynamic Macros</li> <li>Adding new Dynamic Macros without restarting Klipper</li> <li>Removing existing Dynamic Macros without restarting Klipper</li> <li>Renaming Dynamic Macros without restarting Klipper</li> <li>Dynamic Macro descriptions</li> <li>Dynamic Macro variables</li> <li>Retrieving variables from other macros</li> <li>Support for <code>rename_existing</code></li> <li>Running Python from within a Dynamic Macro</li> <li>Dynamic <code>delayed_gcode</code> implementation</li> </ul>"},{"location":"devstatus/#planned-features","title":"Planned Features","text":"<p>A checkmark indicates a feature is experimental.</p> <ul> <li> Allow configuring multiple <code>dynamicmacros</code> config sections as clusters<ul> <li> Disable Python per-cluster</li> <li> Disable <code>printer</code> object per-cluster</li> </ul> </li> <li> Better error handling</li> <li> Klippy extras tutorial</li> </ul>"},{"location":"examples/","title":"Example Macros","text":"<p>This page will hold several different Dynamic Macro examples. Note that most of the examples here are specific to Dynamic Macros only.</p>"},{"location":"examples/#m900","title":"M900","text":"<p>Normal Macro</p> <p>In Marlin, M900 K is used to set pressure/linear advance. Now, you can use it in Klipper too:</p> <pre><code>[gcode_macro M900]\ndescription: Set Pressure Advance\ngcode:\n  {% set k = params.K|default(0)|float %}\n  {% if k &lt; 1 %}\n    SET_PRESSURE_ADVANCE ADVANCE={k}\n  {% endif %}\n</code></pre>"},{"location":"examples/#recursion","title":"Recursion","text":"<p>Dynamic Macro</p> <p>These are a few example Dynamic Macros to demonstrate the recursive functionality of Dynamic Macros.</p> Counting to 10<pre><code>[gcode_macro COUNT]\ngcode:\n    {% set num = params.NUM|default(1)|int %}\n    {% if num &lt;= 10 %}\n        RESPOND MSG={num}\n        COUNT NUM={num+1} # Count up 1\n    {% else %}\n        RESPOND MSG=\"Done Counting\"\n    {% endif %}\n</code></pre> Load to Filament Sensor<pre><code>[gcode_macro LOAD_TO_FSENSOR]\ngcode:\n    {% set val = printer[\"filament_sensor fsensor\"].filament_detected %}\n    {% if val == 0 %}\n        M83\n        G1 E50 F900 # Move filament 50mm forwards\n        RESPOND MSG=\"Waiting for fsensor\"\n        LOAD_TO_FSENSOR # Recursion\n    {% else %}\n        G1 E65 F900 # Move filament to nozzle\n        RESPOND MSG=\"Filament Loaded\"\n    {% endif %}\n</code></pre>"},{"location":"examples/#receiving-position-updates","title":"Receiving Position Updates","text":"<p>Dynamic Macro</p> <p>This is an example Dynamic Macro to demonstrate the ability to receive position updates from within the same macro.</p> <pre><code>[gcode_macro DYNAMIC_MOVE]\ngcode:\n  G28\n\n\n  M117 Before: {printer.toolhead.position.z}\n  # Above displays position after G28\n  G90\n  G1 Z20\n\n\n  M117 After: {printer.toolhead.position.z}\n  # Above displays position after G1\n</code></pre>"},{"location":"examples/#preserving-variables","title":"Preserving Variables","text":"<p>Dynamic Macro</p> <p>This is an example of how to preserve variables across triple-newlines in Dynamic Macros.</p> <pre><code>[gcode_macro VARIABLES]\ngcode:\n    {% set num = update(\"num\", 10) %}\n    M117 {num}\n\n\n    M117 {num}\n    # Above line outputs 10\n</code></pre>"},{"location":"setup/","title":"Setup","text":"<p>Follow this guide to setup and confiure Dynamic Macros.</p>"},{"location":"setup/#install","title":"Install","text":"<p>Run in your terminal:</p> <pre><code>cd ~\ngit clone https://github.com/3DCoded/DynamicMacros\ncd DynamicMacros\nsh install.sh\nsudo service klipper restart\n</code></pre> <p>Add to your <code>moonraker.conf</code>:</p> moonraker.conf<pre><code># DynamicMacros Update Manager\n[update_manager DynamicMacros]\ntype: git_repo\npath: ~/DynamicMacros\norigin: https://github.com/3DCoded/DynamicMacros.git\nprimary_branch: main\nis_system_service: False\ninstall_script: install.sh\n</code></pre>"},{"location":"setup/#updating","title":"Updating","text":"<p>First, update via Moonraker's update manager. Then run in your terminal:</p> <pre><code>cd ~/DynamicMacros\nsh install.sh\nsudo service klipper restart\n</code></pre>"},{"location":"setup/#configuration","title":"Configuration","text":"<p>To configure Dynamic Macros, put in your <code>printer.cfg</code> (or a file included in it):</p> printer.cfg<pre><code>[dynamicmacros]\nconfig_path: ~/printer_data/config # If you left your printer configuration path as the default, you don't need to specify this\nconfigs: dynamic.cfg\n</code></pre> <p>Create a new file in the same folder as your <code>printer.cfg</code> called <code>dynamic.cfg</code>. In it, configure some macros like you normally would. Example:</p> dynamic.cfg<pre><code>[gcode_macro MYTEST]\ngcode:\n    M117 Hello world!\n\n[gcode_macro HEAT_HOTEND]\ngcode:\n    {% set temp = params.TEMP|int %}\n    M104 S{temp}\n</code></pre> <p>Restart Klipper.</p> <p>Info</p> <p>Updating the <code>[dynamicmacros]</code> config section requires a Klipper restart. The files listed in the <code>macros:</code> parameter must be present when Klipper restarts.</p>"},{"location":"setup/#testing","title":"Testing","text":"<p>If you run the command <code>MYTEST</code>, the output should be: <pre><code>Hello world!\n</code></pre></p> <p>If you runthe command <code>HEAT_HOTEND TEMP=200</code>, the hotend should start heating up. </p> <p>Next, edit the <code>MYTEST</code> macro to output something else, like <code>Test successful!</code></p> dynamic.cfg<pre><code>[gcode_macro MYTEST]\ngcode:\n    M117 Test successful!\n</code></pre> <p>Save the file, but do not restart Klipper.</p> <p>Run <code>MYTEST</code> again, and the output should be: <pre><code>Test successful!\n</code></pre></p>"},{"location":"setup/#features","title":"Features","text":"<ul> <li>Recursion</li> <li>Receiving Variable Updates</li> <li>Utility Functions</li> <li>Variables</li> </ul>"},{"location":"setup/#tutorial","title":"Tutorial","text":"<p>Follow the Tutorial.</p>"},{"location":"setup/#when-to-restart-klipper-or-reload-dynamic-macros","title":"When to Restart Klipper or Reload Dynamic Macros","text":"<p>Dynamic Macros provides a utility <code>DYNAMIC_MACRO</code> command to run macros manually, and to refresh the macros. Usage examples (assuming M900 is defined as a Dynamic Macro):</p> <pre><code>DYNAMIC_MACRO MACRO=M900 K=0.035\n</code></pre> <p>is the same as:</p> <pre><code>M900 K0.035\n</code></pre> <p>To refresh Dynamic Macros, just run <code>DYNAMIC_MACRO</code> with no parameters.</p> <p>A Klipper restart is required if:</p> <ul> <li>You changed the <code>description</code></li> <li>You changed the <code>initial_duration</code></li> <li>You changed the <code>repeat</code></li> </ul> <p>A <code>DYNAMIC_MACRO</code> refresh is required if:</p> <ul> <li>You created a new macro</li> <li>You renamed an existing macro</li> <li>You changed the contents of a macro</li> <li>You deleted an existing macro</li> </ul>"},{"location":"extras/extras-ex1/","title":"Example 1: Greeter (Structure)","text":"<p>Before you start to write a Klippy extra, it is important to understand the structure of a Klippy extra. </p> <p>In Python, a Klippy extra is defined as a class, then referenced in a function at the end of the file. Example:</p> greeter.py<pre><code>class Greeter:\n...\n\ndef load_config(config):\n    return Greeter(config)\n</code></pre> <p>There are two functions that can be used at the end of a file:</p> <ul> <li><code>load_config_prefix</code>, allows for configurations like <code>[greeter mygreeter]</code></li> <li><code>load_config</code>, like in this example, allows for configurations like <code>[greeter]</code></li> </ul>"},{"location":"extras/extras-ex1/#initializer","title":"Initializer","text":"<p>In the last line of the above code block, you can see that a <code>config</code> object is passed as a parameter to the <code>Greeter</code> object. The initializer of the <code>Greeter</code> class is shown below in sections:</p> Get printer objects and configuration options<pre><code>    def __init__(self, config):\n        self.printer = config.get_printer()\n        self.reactor = self.printer.get_reactor()\n        self.gcode = self.printer.lookup_object('gcode')\n\n        self.message = config.get('message', 'Welcome to Klipper!')\n</code></pre> <p>This section gets the <code>printer</code> object with <code>config.get_printer()</code>.</p> <p>It then gets the <code>gcode</code> object with <code>self.printer.lookup_object('gcode')</code>.</p> <p>Then, it gets the <code>reactor</code> object with <code>self.printer.get_reactor()</code>.</p> <p>After that, it reads the configuration to get the <code>message</code> parameter, specifying <code>'Welcome to Klipper!'</code> as the default, using <code>config.get('message', 'Welcome to Klipper!')</code>.</p> <p>The next part of the initializer:</p> Register GCode command and event handler<pre><code>        self.gcode.register_command(\n            'GREET', self.cmd_GREET, desc=self.cmd_GREET_help)\n        self.printer.register_event_handler(\n            'klippy:ready', self._ready_handler)\n</code></pre> <p>The <code>self.gcode</code> object is used here to register the <code>GREET</code> command: </p> <p><code>self.gcode.register_command('GREET', self.cmd_GREET, desc=self.cmd_GRRET_help)</code></p> <p>The <code>self.printer</code> object is then used to register an event handler to run when Klippy starts:</p> <p><code>self.printer.register_event_handler('klippy:ready', self._ready_handler)</code></p> Event handlers <p>Klipper supports the following event handlers for extras to use:</p> <ul> <li><code>\"klippy:ready\"</code></li> <li><code>\"klippy:firmware_restart\"</code></li> <li><code>\"klippy:disconnect\"</code></li> </ul> <p>The combined initializer is: greeter.py<pre><code>    def __init__(self, config):\n        self.printer = config.get_printer()\n        self.reactor = self.printer.get_reactor()\n        self.gcode = self.printer.lookup_object('gcode')\n\n        self.message = config.get('message', 'Welcome to Klipper!')\n\n        self.gcode.register_command(\n            'GREET', self.cmd_GREET, desc=self.cmd_GREET_help)\n        self.printer.register_event_handler(\n            'klippy:ready', self._ready_handler)\n</code></pre></p>"},{"location":"extras/extras-ex1/#functions","title":"Functions","text":"<p>The next part of this Klippy extra is the class functions. This class has three functions aside from the initializer, two of which were mentioned in the <code>__init__</code> function:</p> <ul> <li><code>cmd_GREET</code></li> <li><code>_ready_handler</code></li> </ul> <p>This example will start with the <code>_ready_handler</code> function:</p> _ready_handler<pre><code>    def _ready_handler(self):\n        waketime = self.reactor.monotonic() + 1\n        self.reactor.register_timer(self._greet, waketime)\n</code></pre> <p>This event handler sets a timer for one second after Klippy starts to run <code>_greet()</code>. <code>self.reactor.monotonic()</code> represents the current time, and <code>+ 1</code> adds one second. <code>self.reactor.register_timer</code> registers <code>_greet()</code> to run when <code>waketime</code> occurs.</p> _greet()<pre><code>    def _greet(self, eventtime=None):\n        self.gcode.respond_info(self.message)\n        return self.reactor.NEVER\n</code></pre> <p>This function uses the <code>self.gcode</code> object declared in the initializer. Here, the <code>respond_info</code> command is used (similar to running <code>RESPOND MSG=\"\"</code>) to display <code>self.message</code>.</p> What is <code>eventtime</code>? <p>You may have noticed that <code>eventtime</code> is passed to the <code>_greet()</code> function. This is because when Klippy runs <code>_greet()</code> from the previous <code>register_timer</code>, it passes <code>eventtime</code> as a parameter. This is useful if you want a function to repeat itself after a specified interval. In this case, we only want it to run once, so <code>eventtime</code> is unused.</p> The <code>self.gcode</code> object <p>The <code>self.gcode</code> object has a few useful functions:</p> <ul> <li><code>register_command</code> (used in the initializer)</li> <li><code>register_mux_command</code> (explained later)</li> <li><code>respond_info</code> (used here)</li> <li><code>run_script_from_command</code> (runs the provided string as GCode. The provided string can be multiple lines long)</li> </ul> <p>Finally, the <code>cmd_GREET</code> function:</p> cmd_GREET<pre><code>    cmd_GREET_help = \"Greet the user\"\n    def cmd_GREET(self, gcmd):\n        self._greet()\n</code></pre> <p>Here, you can see the <code>cmd_GREET_help</code> is set to a string. Next, the <code>cmd_GREET</code> function takes in a <code>gcmd</code> parameter (unused). Finally, the <code>cmd_GREET</code> function calls <code>_greet()</code>.</p> The <code>gcmd</code> parameter <p>The <code>gcmd</code> parameter allows functions to receive parameters. For example, if <code>GREET REPEAT=3</code> was called, the <code>REPEAT</code> parameter could be read as follows:</p> <pre><code>repeat = gcmd.get_int('REPEAT', 1)\n</code></pre> <p>There are a few <code>get_</code> functions that can be used with the <code>gcmd</code> parameter:</p> <ul> <li><code>get</code> returns a <code>str</code></li> <li><code>getint</code> returns an <code>int</code></li> <li><code>getfloat</code> returns a <code>float</code></li> </ul> <p><code>gcmd</code> also has a <code>respond_info</code> function, similar to the <code>self.gcode.respond_info</code> function.</p> <p>The <code>repeat</code> variable can then be used:</p> <pre><code>for _ in range(repeat):\n    self._greet()\n</code></pre>"},{"location":"extras/extras-ex1/#install","title":"Install","text":"<p>To install a Klippy extra, it has to be placed in the <code>~/klipper/klippy/extras/</code> folder. Here's a simple command to install <code>greeter.py</code>:</p> <pre><code>cp greeter.py ~/klipper/klippy/extras/greeter.py\n</code></pre> <p>You can also create an install script that uses the <code>ln</code> command to create a link to the file, rather than a copy:</p> install.sh<pre><code>ln -f greeter.py ~/klippy/klippy/extras/greeter.py\n</code></pre>"},{"location":"extras/extras-ex1/#other-things","title":"Other Things","text":"<p>A few things that are good to know before moving on:</p> <ul> <li>If your Klippy extra uses <code>load_config_prefix</code>, instead of <code>load_config</code>, you can get the name of the configuration section (e.g. <code>[greeter first]</code> is named <code>first</code>) by using:      <pre><code>config.get_name().split()[1]\n</code></pre></li> <li>If you want to learn more about additional capabilities of Klippy extras, check out the built-in Klippy extras.</li> <li>For further explanation of topics on this page, open the dropdowns.</li> </ul> <p>Next example:</p> <p>Example 2: BetterGreeter </p>"},{"location":"extras/extras-ex2/","title":"Example 2: BetterGreeter","text":"<p>For this tutorial, we are going to improve on the greeter code used in Structure. </p> <p>For reference, the entire original greeter code is below:</p> Original Greeter <pre><code>class Greeter:\n    def __init__(self, config):\n        self.printer = config.get_printer()\n        self.reactor = self.printer.get_reactor()\n        self.gcode = self.printer.lookup_object('gcode')\n\n        self.message = config.get('message', 'Welcome to Klipper!')\n\n        self.gcode.register_command(\n            'GREET', self.cmd_GREET, desc=self.cmd_GREET_help)\n        self.printer.register_event_handler(\n            'klippy:ready', self._ready_handler)\n\n    def _ready_handler(self):\n        waketime = self.reactor.monotonic() + 1\n        self.reactor.register_timer(self._greet, waketime)\n\n    def _greet(self, eventtime=None):\n        self.gcode.respond_info(self.message)\n        return self.reactor.NEVER\n\n    cmd_GREET_help = \"Greet the user\"\n    def cmd_GREET(self, gcmd):\n        self._greet()\n\ndef load_config(config):\n    return Greeter(config)\n</code></pre>"},{"location":"extras/extras-ex2/#goals","title":"Goals","text":"<p>For the <code>BetterGreeter</code>, we want the following features:</p> <ul> <li>Ability to have multiple different greetings</li> <li>Allow the user to choose if they want their greeting to display after Klipper starts, and if so, to set the delay</li> <li>Allow the user to set the message of the greeting</li> </ul> <p>Here's an example configuration:</p> better_greeter.cfg<pre><code>[greeting welcome]\nmessage: Welcome to Klipper!\ndelay: 1\n\n[greeting gcode]\nmessage: Upload some GCode!\ndelay: 2\n\n[greeting print_done]\nmessage: Print completed!\n</code></pre> <p>Here's the desired behavior (anything on the line of a <code>&gt;</code> is a user-typed command):</p> <pre><code>&gt; RESTART\nWelcome to Klipper! # (1)!\nUpload some GCode! # (2)!\n&gt; GREETING NAME=print_done\nPrint completed!\n</code></pre> <ol> <li>One second after <code>RESTART</code></li> <li>Two seconds after <code>RESTART</code></li> </ol>"},{"location":"extras/extras-ex2/#creating-the-base-class","title":"Creating the Base Class","text":"<p>The first step of creating a Klippy extra is to make the base class and the config function: </p> <pre><code>class Greeting:\n    def __init__(self, config):\n        pass\n\n# (1)!\ndef load_config_prefix(config):\n    return Greeting(config)\n</code></pre> <ol> <li><code>load_config_prefix</code> is used here instead of <code>load_config</code> because there will be multiple <code>greeter</code> configuration sections.</li> </ol>"},{"location":"extras/extras-ex2/#reading-the-configuration","title":"Reading the Configuration","text":"<p>The next step of our Klippy extra is to setup the class variables and read the parameters:</p> <pre><code>class Greeting:\n    def __init__(self, config):\n        self.printer = config.get_printer()\n        self.reactor = self.printer.get_reactor()\n        self.gcode = self.printer.lookup_object('gcode')\n        self.name = config.get_name().split()[1]\n\n        self.message = config.get('message', 'Welcome to Klipper!')\n        self.delay = config.getint('delay', 0)\n</code></pre> <p>Quiz</p> QuestionAnswer <p>If there was a configuration option (int) named <code>repeats</code>, how would you get it in the initializer?</p> <p><code>config.getint('repeats')</code></p> <p>Here, the <code>printer</code>, <code>reactor</code>, <code>gcode</code>, and <code>message</code> variables are the same as in the previous Klippy extra. However, in this case, there are a couple new variables:</p> <ul> <li><code>name</code> is explained in the last section of Structure.</li> <li><code>delay</code> is read as an <code>int</code> from the <code>config</code> object, with default value <code>0</code>. The default value of <code>0</code> indicates it will not be run when Klippy starts.</li> </ul>"},{"location":"extras/extras-ex2/#gcode-commands-and-event-handler","title":"GCode Commands and Event Handler","text":"<p>After reading the configuration variables, we need to setup the GCode commands and event handler:</p> <pre><code>class Greeting:\n    def __init__(self, config):\n        self.printer = config.get_printer()\n        self.reactor = self.printer.get_reactor()\n        self.gcode = self.printer.lookup_object('gcode')\n        self.name = config.get_name().split()[1]\n\n        self.message = config.get('message', 'Welcome to Klipper!')\n        self.delay = config.getint('delay', 0)\n\n        #(1)!\n        self.gcode.register_mux_command(\n            'GREETING',\n            'NAME',\n            self.name,\n            self.cmd_GREETING,\n            desc=self.cmd_GREETING_help\n        )\n\n        if self.delay &gt; 0:\n            self.printer.register_event_handler(\n            'klippy:ready', self._ready_handler)\n</code></pre> <ol> <li><code>register_mux_command</code> is used here because there are multiple <code>greeting</code> configuration sections, and each should be called separately.</li> </ol> <p>Here, a few parts are similar to the example in Structure, but not identical. Let's start with the GCode command.</p> <p>In the Structure example, the GCode command was registered with:</p> <p><code>self.gcode.register_command('GREET', self.cmd_GREET, desc=self.cmd_GREET_help)</code></p> <p>In this new example, the GCode command is registered with:</p> <pre><code>self.gcode.register_mux_command(\n    'GREETING',\n    'NAME',\n    self.name,\n    self.cmd_GREETING,\n    desc=self.cmd_GREETING_help\n)\n</code></pre> <p>The difference here is that there can be multiple <code>greeting</code> configuration sections, and as a result, multiple <code>Greeting</code> objects. To call each one separately, <code>register_mux_command</code> is used, passing the following parameters:</p> <ul> <li>Macro name: <code>\"GREETING\"</code></li> <li>Parameter name: <code>\"NAME\"</code></li> <li>Parameter value: <code>self.name</code></li> <li>Function: <code>self.cmd_GREETING</code></li> <li>Description <code>self.cmd_GREETING_help</code></li> </ul> <p>Next, the <code>register_event_handler</code> is nearly identical to the Structure example, except in this case, it is run only <code>if self.delay &gt; 0</code>.</p>"},{"location":"extras/extras-ex2/#functions","title":"Functions","text":"<p>The next part to creating this Klippy extra is the functions.</p> <p>There are three functions in the <code>Greeting</code> class:</p> <ul> <li><code>ready_handler</code></li> <li><code>_greet</code></li> <li><code>cmd_GREETING</code></li> </ul> Flowchart <pre><code>graph TD\nA[klippy:ready] --&gt; B[_ready_handler]\n    B --&gt; C[Wait self.delay seconds]\n    C --&gt; D[_greet]\n    D --&gt; E[Display self.message]\n    F[cmd_GREETING] --&gt; E</code></pre> <p>The first function, <code>_ready_handler</code>:</p> greeting.py<pre><code>class Greeting:\n    def __init__(self, config):\n        self.printer = config.get_printer()\n        self.reactor = self.printer.get_reactor()\n        self.gcode = self.printer.lookup_object('gcode')\n        self.name = config.get_name().split()[1]\n\n        self.message = config.get('message', 'Welcome to Klipper!')\n        self.delay = config.getint('delay', 0)\n        self.gcode.register_mux_command(\n            'GREETING',\n            'NAME',\n            self.name,\n            self.cmd_GREETING,\n            desc=self.cmd_GREETING_help\n        )\n\n        if self.delay &gt; 0:\n            self.printer.register_event_handler(\n            'klippy:ready', self._ready_handler)\n\n    def _ready_handler(self):\n        waketime = self.reactor.monotonic() + self.delay\n        self.reactor.register_timer(self._greet, waketime)\n</code></pre> <p>This function takes no parameters, and runs when Klippy reports <code>\"klippy:ready\"</code>.</p> <p>Inside, the <code>waketime</code> variable is declared as <code>self.reactor.monotonic() + self.delay</code>. Let's break this declaration down:</p> <ul> <li><code>self.reactor.monotonic()</code> This is the current Klippy time</li> <li><code>+ self.delay</code> This adds <code>self.delay</code> to the current time.</li> </ul> <p>The result is that <code>waketime</code> contains the Klippy time for <code>self.delay</code> seconds in the future. Finally, we use <code>self.reactor.register_timer</code> to register this time, telling it to run <code>self._greet()</code> when the time occurs.</p> <p>The next function, <code>_greet</code>:</p> greeting.py<pre><code>class Greeting:\n    def __init__(self, config):\n        self.printer = config.get_printer()\n        self.reactor = self.printer.get_reactor()\n        self.gcode = self.printer.lookup_object('gcode')\n        self.name = config.get_name().split()[1]\n\n        self.message = config.get('message', 'Welcome to Klipper!')\n        self.delay = config.getint('delay', 0)\n        self.gcode.register_mux_command(\n            'GREETING',\n            'NAME',\n            self.name,\n            self.cmd_GREETING,\n            desc=self.cmd_GREETING_help\n        )\n\n        if self.delay &gt; 0:\n            self.printer.register_event_handler(\n            'klippy:ready', self._ready_handler)\n\n    def _ready_handler(self):\n        waketime = self.reactor.monotonic() + self.delay\n        self.reactor.register_timer(self._greet, waketime)\n\n    def _greet(self, eventtime=None):\n        self.gcode.respond_info(self.message)\n        return self.reactor.NEVER\n</code></pre> <p>This function takes an optional <code>eventtime</code> parameter (unused) (1), and prints out <code>self.message</code> to the Klipper console, using <code>self.gcode.respond_info</code>.</p> <ol> <li>This is passed by Klippy when it calls <code>_greet()</code> after the timer occurs.</li> </ol> <p>Tip</p> <p>If you want the timer function to repeat, you can return the provided <code>eventtime</code> plus any number of seconds in the future, and it will repeat.</p> <p>The final function in this class is the <code>cmd_GREETING</code> function:</p> greeting.py<pre><code>class Greeting:\n    def __init__(self, config):\n        self.printer = config.get_printer()\n        self.reactor = self.printer.get_reactor()\n        self.gcode = self.printer.lookup_object('gcode')\n        self.name = config.get_name().split()[1]\n\n        self.message = config.get('message', 'Welcome to Klipper!')\n        self.delay = config.getint('delay', 0)\n        self.gcode.register_mux_command(\n            'GREETING',\n            'NAME',\n            self.name,\n            self.cmd_GREETING,\n            desc=self.cmd_GREETING_help\n        )\n\n        if self.delay &gt; 0:\n            self.printer.register_event_handler(\n            'klippy:ready', self._ready_handler)\n\n    def _ready_handler(self):\n        waketime = self.reactor.monotonic() + self.delay\n        self.reactor.register_timer(self._greet, waketime)\n\n    def _greet(self, eventtime=None):\n        self.gcode.respond_info(self.message)\n        return self.reactor.NEVER\n\n    cmd_GREETING_help = \"Greet the user\"\n    def cmd_GREETING(self, gcmd):\n        self._greet()\n</code></pre> <p>This function simply calls <code>self._greet()</code>, which displays <code>self.message</code> to the Klipper terminal.</p>"},{"location":"extras/extras-ex2/#full-code","title":"Full Code","text":"<p>The full code of this Klippy extra is:</p> greeting.py<pre><code>class Greeting:\n    def __init__(self, config):\n        self.printer = config.get_printer()\n        self.reactor = self.printer.get_reactor()\n        self.gcode = self.printer.lookup_object('gcode')\n        self.name = config.get_name().split()[1]\n\n        self.message = config.get('message', 'Welcome to Klipper!')\n        self.delay = config.getint('delay', 0)\n\n        self.gcode.register_mux_command(\n            'GREETING',\n            'NAME',\n            self.name,\n            self.cmd_GREETING,\n            desc=self.cmd_GREETING_help\n        )\n\n        if self.delay &gt; 0:\n            self.printer.register_event_handler(\n            'klippy:ready', self._ready_handler)\n\n    def _ready_handler(self):\n        waketime = self.reactor.monotonic() + self.delay\n        self.reactor.register_timer(self._greet, waketime)\n\n    def _greet(self, eventtime=None):\n        self.gcode.respond_info(self.message)\n        return self.reactor.NEVER\n\n    cmd_GREETING_help = \"Greet the user\"\n    def cmd_GREETING(self, gcmd):\n        self._greet()\n\ndef load_config_prefix(config):\n    return Greeting(config)\n</code></pre> <p>You can install it following these instructions, replacing <code>greeter.py</code> with <code>greeting.py</code>.</p> <p>Last example (so far):</p> <p>Example 3: KlipperMaintenance </p>"},{"location":"extras/extras-ex3/","title":"Example 3: KlipperMaintenance","text":"<p>This last example of the Klippy extra development tutorial is actually one of my other Klipper projects: KlipperMaintenance, a maintenance reminder system for Klipper.</p> <p>This example will go through how the KlipperMaintenance code works to teach a few more important things about developing Klippy extras.</p>"},{"location":"extras/extras-ex3/#full-code","title":"Full Code","text":"<p>For this tutorial, we'll start with the full code, then break it down and explain what each section does. If you can learn to read existing Klippy extras, you can read the builtin Klippy extras when developing your own extras.</p> Full Code <pre><code>import json\nimport os\nimport time\nimport urllib.request as requests\n\nAPI_URL = 'http://localhost:7125/server/history/totals'\nHOME_DIR = os.path.expanduser('~')\n\nclass Maintenance:\n    def __init__(self, config):\n        self.config = config\n        self.printer = config.get_printer()\n        self.reactor = self.printer.get_reactor()\n        self.gcode = self.printer.lookup_object('gcode')\n\n        self.interval = config.getint('interval', 60)\n\n        self.timer_handler = None\n        self.inside_timer = self.repeat = False\n        self.printer.register_event_handler(\"klippy:ready\", self._handle_ready)\n\n        self.gcode.register_command('MAINTAIN_STATUS', self.cmd_MAINTAIN_STATUS, desc=self.cmd_MAINTAIN_STATUS_help)\n\n    def _handle_ready(self):\n        waketime = self.reactor.monotonic() + self.interval\n        self.timer_handler = self.reactor.register_timer(\n            self._gcode_timer_event, waketime)\n\n    def _gcode_timer_event(self, eventtime):\n        self.inside_timer = True\n        self.check_maintenance()\n        nextwake = eventtime + self.interval\n        self.inside_timer = self.repeat = False\n        return nextwake\n\n    def check_maintenance(self):\n        objs = self.printer.lookup_objects('maintain')\n        for obj in objs:\n            obj = obj[1]\n            if not isinstance(obj, Maintain):\n                continue\n            if obj.get_remaining() &lt; 0:\n                self.gcode.respond_info(f'Maintenance \"{obj.label}\" Expired!\\n{obj.message}')\n                self.gcode.run_script_from_command('M117 Maintenance Expired!')\n\n    cmd_MAINTAIN_STATUS_help = 'Check status of maintenance'\n    def cmd_MAINTAIN_STATUS(self, gcmd):\n        objs = self.printer.lookup_objects('maintain')\n        for obj in objs:\n            obj = obj[1]\n            if not isinstance(obj, Maintain):\n                continue\n            remain = obj.get_remaining()\n            if remain &lt; 0:\n                self.gcode.respond_info(f'Maintenance \"{obj.label}\" Expired!\\n{obj.message}')\n            self.gcode.respond_info(f'{obj.label}: {obj.get_remaining()}{obj.units} remaining')\n\nclass Maintain:\n    def __init__(self, config):\n        self.config = config\n        self.printer = config.get_printer()\n        self.gcode = self.printer.lookup_object('gcode')\n        self.name = config.get_name().split()[1]\n\n        self.label = config.get('label')\n\n        self.trigger = config.getchoice('trigger', ['print_time', 'filament', 'time'])\n        if self.trigger == 'print_time':\n            self.units = 'h'\n        elif self.trigger == 'filament':\n            self.units = 'm'\n        elif self.trigger == 'time':\n            self.units = 'h'\n\n        self.threshold = config.getint('threshold')\n        self.message = config.get('message')\n\n        self.init_db()\n\n        # register GCode commands\n        self.gcode.register_mux_command('CHECK_MAINTENANCE', 'NAME', self.name, self.cmd_CHECK_MAINTENANCE, desc=self.cmd_CHECK_MAINTENANCE_help)\n        self.gcode.register_mux_command('UPDATE_MAINTENANCE', 'NAME', self.name, self.cmd_UPDATE_MAINTENANCE, desc=self.cmd_UPDATE_MAINTENANCE_help)\n\n    def fetch_history(self):\n        resp = requests.urlopen(API_URL) # fetch data from Moonraker History API\n        try:\n            json_data = json.loads(resp.read())\n        except Exception:\n            self.gcode.respond_info(f'Data {resp.read()}')\n            return {\n                'print_time': 0,\n                'filament': 0,\n                'time': time.time()/3600\n            }\n\n        job_totals = json_data['result']['job_totals'] # get job totals from JSON response\n        return {\n            'print_time': job_totals['total_time']/3600,\n            'filament': job_totals['total_filament_used']/1000,\n            'time': time.time()/3600\n        }\n\n    def init_db(self):\n        data = self.fetch_db()\n        if data is None:\n            data = self.fetch_history()\n            self.update_db(data)\n\n    def fetch_db(self):\n        path = os.path.join(HOME_DIR, f'maintain-db/{self.name}')\n        if os.path.exists(path):\n            with open(path, 'r') as file:\n                try:\n                    data = json.load(file)\n                except:\n                    data = {'print_time': 0, 'filament': 0, 'time': time.time()/3600}\n                return data\n\n    def update_db(self, new):\n        path = os.path.join(HOME_DIR, f'maintain-db/{self.name}')\n        os.makedirs(os.path.dirname(path), exist_ok=True)\n        with open(path, 'w+') as file:\n            try:\n                data = json.load(file)\n            except:\n                data = {'print_time': 0, 'filament': 0, 'time': time.time()/3600}\n            data.update(new)\n            json.dump(data, file)\n        return data\n\n    def get_remaining(self):\n        last = self.fetch_db()[self.trigger]\n        now = self.fetch_history()[self.trigger]\n        return round(self.threshold - (now - last), 2)\n\n    cmd_CHECK_MAINTENANCE_help = 'Check maintenance'\n    def cmd_CHECK_MAINTENANCE(self, gcmd):\n        gcmd.respond_info(f'''\nMaintenance {self.label} Status:\nNext maintenance in {self.get_remaining()}{self.units}\nMaintenance message: {self.message}\n        '''.strip())\n\n    cmd_UPDATE_MAINTENANCE_help = 'Update maintenance'\n    def cmd_UPDATE_MAINTENANCE(self, gcmd):\n        self.update_db(self.fetch_history())\n\ndef load_config(config):\n    return Maintenance(config)\n\ndef load_config_prefix(config):\n    return Maintain(config)\n</code></pre>"},{"location":"extras/extras-ex3/#structure","title":"Structure","text":"<p>The class structure of this Klippy extra is shown in this flowchart:</p> <pre><code>classDiagram\n    class Maintain{\n        str name\n        str label\n        str trigger\n        int threshold\n        str message\n        fetch_history()\n        init_db()\n        fetch_db()\n        update_db(new)\n        get_remaining()\n        cmd_CHECK_MAINTENANCE(gcmd)\n        cmd_UPDATE_MAINTENANCE(gcmd)\n    }\n    note for Maintain \"trigger must be one of:\\n - print_time\\n - filament\\n - time\"\n\n    class Maintenance{\n        int interval\n        _handle_ready()\n        _gcode_timer_event()\n        check_maintenance()\n        cmd_MAINTAIN_STATUS(gcmd)\n    }\n\n    Maintenance &lt;|-- Maintain: Has-a</code></pre> <p>This diagram has a lot of information, but the key points are:</p> <ul> <li>Multiple <code>Maintain</code> objects are managed by one <code>Maintainence</code> object.</li> <li>The <code>Maintain</code> class handles maintenance reminders, the <code>CHECK_MAINTENANCE</code> command, and the <code>UPDATE_MAINTENANCE</code> command.</li> <li>The <code>Maintenance</code> class handles the <code>MAINTAIN_STATUS</code> command.</li> <li>A <code>[maintain name]</code> section corresponds to the <code>Maintain</code> class (multiple).</li> <li>A <code>[maintain]</code> section corresponds to the <code>Maintenance</code> class (one).</li> </ul> <p>The base code for this is:</p> maintain.py<pre><code>import json\nimport os\nimport time\nimport urllib.request as requests\n\nAPI_URL = 'http://localhost:7125/server/history/totals'\nHOME_DIR = os.path.expanduser('~')\n\nclass Maintenance:\n    pass\n\nclass Maintain:\n    pass\n\n# (1)!\ndef load_config(config):\n    return Maintenance(config)\n\n# (2)!\ndef load_config_prefix(config):\n    return Maintain(config)\n</code></pre> <ol> <li>This function corresponds to a <code>[maintain]</code> config section.</li> <li>This function corresponds to a <code>[maintain name]</code> config section.</li> </ol> <p>The highlighted section in the code contains the classes, and the configuration loading, the parts relevant to this first section. The code above the highlighted section includes the relevant module imports and constant declarations (both explained later).</p> <p>Much of the content in this example will be embedded in the code (usually the highlighted section) as a plus sign, like this: (1)</p> <ol> <li>Click some more plus marks in the code to learn more about the code.</li> </ol>"},{"location":"extras/extras-ex3/#maintain-class","title":"<code>Maintain</code> class","text":"<p>This next section of the example will focus on the <code>Maintain</code> class.</p>"},{"location":"extras/extras-ex3/#initializer","title":"Initializer","text":"<p>When <code>load_config_prefix</code> creates a <code>Maintain</code> object, it starts in the initializer. </p> <p>Here's the full initializer, with explanations embedded inside with plus signs. Below is a more general breakdown of the initializer for clarity.</p> maintain.py<pre><code>class Maintain:\n    def __init__(self, config):\n        self.config = config\n        self.printer = config.get_printer()\n        self.gcode = self.printer.lookup_object('gcode')\n        self.name = config.get_name().split()[1] # (1)!\n\n        self.label = config.get('label')\n\n        # (2)!\n        self.trigger = config.getchoice('trigger', ['print_time', 'filament', 'time']) \n        if self.trigger == 'print_time': # (3)!\n            self.units = 'h'\n        elif self.trigger == 'filament':\n            self.units = 'm'\n        elif self.trigger == 'time':\n            self.units = 'h'\n\n        self.threshold = config.getint('threshold')\n        self.message = config.get('message')\n\n        # (4)!\n        self.init_db()\n\n        self.gcode.register_mux_command('CHECK_MAINTENANCE', 'NAME', self.name, self.cmd_CHECK_MAINTENANCE, desc=self.cmd_CHECK_MAINTENANCE_help)\n        self.gcode.register_mux_command('UPDATE_MAINTENANCE', 'NAME', self.name, self.cmd_UPDATE_MAINTENANCE, desc=self.cmd_UPDATE_MAINTENANCE_help)\n</code></pre> <ol> <li><code>config.get_name()</code> returns the full config name, like <code>\"maintain name\"</code>. The <code>.split()[1]</code> splits the name by spaces and gets the last \"word\".</li> <li><code>config.getchoice()</code> allows you to only accept values in a certain list.</li> <li>This part of the initializer chooses the units based on the <code>trigger</code> type:<ul> <li><code>\"print_time\"</code>: <code>\"h\"</code></li> <li><code>\"filament\"</code>: <code>\"m\"</code></li> <li><code>\"time\"</code>: <code>\"h\"</code></li> </ul> </li> <li>This is explained later, in functions.</li> </ol> <p>The major breakdown of this initializer is:</p> <ul> <li>First highlighted section: Load basic objects</li> <li>Second highlighted section: Read configuration options</li> <li>Third highlighted section: Register GCode commands</li> </ul> <p>The line <code>self.init_db()</code> will be explained later in functions.</p> <p>Quiz</p> QuestionAnswer <p>How would you add another trigger type (called <code>\"axes_distance\"</code> with units <code>\"m\"</code>)?</p> <pre><code>self.trigger = config.getchoice('trigger', [\n    'print_time',\n    'filament',\n    'time',\n    'axes_distance'])\nif self.trigger == 'print_time': # (3)!\n    self.units = 'h'\nelif self.trigger == 'filament':\n    self.units = 'm'\nelif self.trigger == 'time':\n    self.units = 'h'\nelif self.trigger == 'axes_distance':\n    self.units = 'm'\n</code></pre>"},{"location":"extras/extras-ex3/#functions","title":"Functions","text":"<p>The next part of the <code>Maintain</code> class is its functions. The functions in this class are, broken down into two sections:</p> <p>Database:</p> <ul> <li><code>fetch_history()</code></li> <li><code>init_db()</code></li> <li><code>fetch_db()</code></li> <li><code>update_db(new)</code></li> </ul> <p>GCode:</p> <ul> <li><code>get_remaining()</code></li> <li><code>cmd_CHECK_MAINTENANCE(gcmd)</code></li> <li><code>cmd_UPDATE_MAINTENANCE(gcmd)</code></li> </ul> <p>First, the database functions (again, plus signs throughout the code explain in more detail what each part does):</p> maintain.py<pre><code>class Maintain:\n    ...\n    def fetch_history(self):\n        resp = requests.urlopen(API_URL) # fetch data from Moonraker History API\n        try:\n            json_data = json.loads(resp.read()) \n        except Exception:\n            self.gcode.respond_info(f'Data {resp.read()}')\n            return {\n                'print_time': 0,\n                'filament': 0,\n                'time': time.time()/3600\n            } # (1)!\n\n        job_totals = json_data['result']['job_totals'] # get job totals from JSON response\n        return {\n            'print_time': job_totals['total_time']/3600,\n            'filament': job_totals['total_filament_used']/1000,\n            'time': time.time()/3600\n        } # (2)!\n\n    def init_db(self):\n        data = self.fetch_db() # Load the database\n        if data is None:\n            data = self.fetch_history()\n            self.update_db(data) # Update the database with history data\n\n    def fetch_db(self):\n        path = os.path.join(HOME_DIR, f'maintain-db/{self.name}') # (3)!\n        if os.path.exists(path):\n            with open(path, 'r') as file:\n                try:\n                    data = json.load(file) # JSON parse the file contents\n                except:\n                    data = {'print_time': 0, 'filament': 0, 'time': time.time()/3600}\n                return data # Return parsed data\n\n    def update_db(self, new):\n        path = os.path.join(HOME_DIR, f'maintain-db/{self.name}') # (3)!\n        os.makedirs(os.path.dirname(path), exist_ok=True) # (4)!\n        with open(path, 'w+') as file: # The \"w+\" file operator allows reading and writing\n            try:\n                data = json.load(file) # JSON parse the file contents\n            except:\n                data = {'print_time': 0, 'filament': 0, 'time': time.time()/3600}\n            data.update(new) # Update the file contents with the new data\n            json.dump(data, file) # JSON write the new data to the file\n        return data # Return the new updated data\n</code></pre> <ol> <li>In case of an error, empty placeholder data is returned.</li> <li>If history fetch was successful, return the data read from the Moonraker History API.</li> <li>The <code>path</code> is (if the username is <code>pi</code> and <code>self.name</code> is <code>\"lubricate\"</code>) <code>\"/home/pi/maintain-db/lubricate\"</code>. Even though it has no file extension, it stores JSON data.</li> <li>The first time running this, the <code>maintain-db</code> folder won't exist. <code>os.makedirs</code> creates the folder, and <code>exist_ok=True</code> doesn't throw an error if it already exists.</li> </ol> <p>The flow of information in this Klippy extra is:</p> <ul> <li><code>init_db()</code> is called when Klippy starts</li> <li><code>fetch_db()</code> is called to read the stored database</li> <li>If the data returned by <code>fetch_db()</code> is <code>None</code> (database is empty)<ul> <li><code>fetch_history()</code> is called to fetch the history stored by Moonraker</li> <li><code>update_db()</code> is called to update the database with the newly fetched data.</li> </ul> </li> </ul> <p>Calling <code>update_db()</code> will erase the current maintenance state (resetting the timer/filament counter).</p> <p>The next section of functions in the <code>Maintain</code> class are the GCode commands. There are three functions in this section:</p> <ul> <li><code>get_remaining()</code></li> <li><code>cmd_CHECK_MAINTENANCE(gcmd)</code></li> <li><code>cmd_UPDATE_MAINTENANCE(gcmd)</code></li> </ul> maintain.py<pre><code>class Maintain:\n    ...\n    def get_remaining(self): # Returns the remaining hours/meters until this expires\n        last = self.fetch_db()[self.trigger] # Get the last trigger\n        now = self.fetch_history()[self.trigger] # Get the current state\n        return round(self.threshold - (now - last), 2) # Return how close the difference is to self.threshold, and round to two decimal places\n\n    cmd_CHECK_MAINTENANCE_help = 'Check maintenance'\n    def cmd_CHECK_MAINTENANCE(self, gcmd):\n        gcmd.respond_info(f'''\nMaintenance {self.label} Status:\nNext maintenance in {self.get_remaining()}{self.units}\nMaintenance message: {self.message}\n        '''.strip())\n\n    cmd_UPDATE_MAINTENANCE_help = 'Update maintenance'\n    def cmd_UPDATE_MAINTENANCE(self, gcmd):\n        self.update_db(self.fetch_history()) # (1)!\n</code></pre> <ol> <li>This erases the current maintenance status, and is called when maintenance has been done. <code>self.fetch_history()</code> retrieves the current state of the printer history (print time, filament), and then <code>self.update_db()</code> saves that data to the JSON database.</li> </ol> <p>The first function, <code>get_remaining</code>, works as follows (assuming the trigger is <code>print_time</code> and threshold is <code>250</code>):</p> <ol> <li>Read the last print time that maintenance occured at</li> <li>Read the current accumulated print time</li> <li>Get the difference between the two (how long has it been since last maintenance?)</li> <li>Subtract that from <code>threshold</code> (how much longer until maintenance should be done?)</li> <li>Round to two decimal places and return</li> </ol> <p>The next function, <code>cmd_CHECK_MAINTENANCE</code>, corresponds to the GCode command <code>CHECK_MAINTENANCE</code>, and outputs the <code>Maintain</code> object's variables in a user-friendly format.</p> <p>The final function, <code>cmd_UPDATE_MAINTENANCE</code>, corresponds to the GCode command <code>UPDATE_MAINTENANCE</code>, and erases the current maintenance state. Click the plus sign in the function for more information.</p>"},{"location":"extras/extras-ex3/#maintenance-class","title":"Maintenance Class","text":"<p>Now that we've gone through the <code>Maintain</code> class, let's see how multiple <code>Maintain</code> objects are managed in the <code>Maintenance</code> class. This class does the following:</p> <ul> <li>Displays maintenance reminders</li> <li>Provides the <code>MAINTAIN_STATUS</code> command to overview the current maintenance state</li> </ul> <p>Unlike the <code>Maintain</code> class, which has multiple objects, there will be only one <code>Maintenance</code> object. Let's start with the initializer.</p>"},{"location":"extras/extras-ex3/#initializer_1","title":"Initializer","text":"<p>The initializer of the <code>Maintenance</code> class is shown below:</p> maintain.py<pre><code>class Maintenance:\n    def __init__(self, config):\n        self.config = config\n        self.printer = config.get_printer()\n        self.reactor = self.printer.get_reactor()\n        self.gcode = self.printer.lookup_object('gcode')\n\n        self.interval = config.getint('interval', 60)\n\n        self.timer_handler = None\n        self.inside_timer = self.repeat = False\n        self.printer.register_event_handler(\"klippy:ready\", self._handle_ready)\n\n        self.gcode.register_command('MAINTAIN_STATUS', self.cmd_MAINTAIN_STATUS, desc=self.cmd_MAINTAIN_STATUS_help)\n</code></pre> <p>This initializer may look similar to the BetterGreeter initializer in the previous example. This is because both the <code>BetterGreeter</code> and <code>Maintenance</code> classes use Klipper's timer system to schedule events. </p> <p>There are four highlighted sections in the above code block. Let's go through each of them and explain what they do. </p> <ol> <li>This sets up the <code>reactor</code> object, which is important in scheduling events with Klipper.</li> <li>This reads the interval from the configuration, defaulting to <code>60</code> if no value is provided.</li> <li>This section is based off the <code>delayed_gcode</code> code, which is builtin to Klipper. Source code here. This section declares a <code>timer_handler</code>, <code>inside_timer</code>, and <code>repeat</code> variables, all of which will be used later. The last line of this section registers the <code>self._handle_ready</code> function to run when Klippy is ready.</li> <li>This final line registers the <code>\"MAINTAIN_STATUS\"</code> GCode command.</li> </ol>"},{"location":"extras/extras-ex3/#functions_1","title":"Functions","text":"<p>The next part of the <code>Maintenance</code> class is its functions:</p> <ul> <li><code>_handle_ready</code></li> <li><code>_gcode_timer_event</code></li> <li><code>check_maintenance</code></li> <li><code>cmd_MAINTAIN_STATUS</code></li> </ul> <p>Click on the plus symbols in the code below to learn more about specific parts.</p> maintian.py<pre><code>class Maintenance:\n    def _handle_ready(self):\n        waketime = self.reactor.monotonic() + self.interval # (1)!\n        self.timer_handler = self.reactor.register_timer(\n            self._gcode_timer_event, waketime)\n\n    def _gcode_timer_event(self, eventtime):\n        # This function is based on the delayed_gcode Klipper code.\n        self.inside_timer = True\n        self.check_maintenance() # Check if maintenance needs to be done.\n        nextwake = eventtime + self.interval\n        self.inside_timer = self.repeat = False\n        return nextwake # (2)!\n\n    def check_maintenance(self):\n        objs = self.printer.lookup_objects('maintain')\n        for obj in objs:\n            obj = obj[1] # (3)!\n            if not isinstance(obj, Maintain): # (4)!\n                continue\n            if obj.get_remaining() &lt; 0: # (5)!\n                self.gcode.respond_info(f'Maintenance \"{obj.label}\" Expired!\\n{obj.message}')\n                self.gcode.run_script_from_command('M117 Maintenance Expired!')\n\n    cmd_MAINTAIN_STATUS_help = 'Check status of maintenance'\n    def cmd_MAINTAIN_STATUS(self, gcmd):\n        objs = self.printer.lookup_objects('maintain') # Load all Maintain objects\n        for obj in objs:\n            obj = obj[1] # (3)!\n            if not isinstance(obj, Maintain): # (4)!\n                continue\n            remain = obj.get_remaining() # You can call functions on other Klippy extras\n            if remain &lt; 0: # (5)!\n                self.gcode.respond_info(f'Maintenance \"{obj.label}\" Expired!\\n{obj.message}')\n            self.gcode.respond_info(f'{obj.label}: {obj.get_remaining()}{obj.units} remaining')\n</code></pre> <ol> <li> <p>Quiz</p> QuestionAnswer What does <code>self.reactor.monotonic()</code> return? <code>self.reactor.monotonic()</code> returns the current Klippy time. </li> <li>This is necessary for the timer to repeat. If you wanted to make this function not repeat, you can make it return <code>self.reactor.NEVER</code>.</li> <li>Whenever you use <code>printer.lookup_objects</code>, it will return a list of tuples, where each tuple contains, in order, the configuration name of the object, then the actual Python object.</li> <li>Because the <code>Maintenance</code> class is also configured with a <code>[maintain]</code> config section (the difference being that <code>Maintenance</code> doesn't have a name, while <code>Maintain</code> does have a name, like <code>[maintain lubricate]</code>), a check has to be made to ensure a <code>Maintain</code> object has been found.</li> <li><code>if get_remaining() &lt; 0</code>, the maintenance is expired and needs to be done.</li> </ol> <p>There are general flows of information in these functions:</p> <p>GCode Flow:</p> <ol> <li><code>MAINTAIN_STATUS</code> is called from GCode</li> <li><code>cmd_MAINTAIN_STATUS</code> is called in Python</li> <li>All <code>Maintain</code> objects are retrieved</li> <li>If a <code>Maintain</code> object is expired, notify the user in the terminal</li> <li>Display the status of all <code>Maintain</code> objects</li> </ol> <p>Timer Flow:</p> <ol> <li>Klippy reports ready and calls <code>_handle_ready</code></li> <li><code>_handle_ready</code> schedules an event to happen in <code>self.interval</code> seconds</li> <li><code>_gcode_timer_event</code> is called by Klippy, and the maintenance is checked</li> <li>Repeat step 3 until Klippy shuts down</li> </ol> <p>The first flow, the GCode flow, runs when the user manually runs the <code>MAINTAIN_STATUS</code> command. This makes it useful for checking how close certain maintenance objects are to being expired.</p> <p>The second flow, the timer flow, runs behind the scenes as long as Klippy is running. This makes it useful for reminding the user if maintenance needs to be done without the need for manually checking.</p> <p>Tip</p> <p>Using a combination of GCode-initiated code, and timer-initiated code allows for Klippy extras to be more user-friendly.</p>"},{"location":"extras/extras-ex3/#feedback","title":"Feedback","text":"<p>Was this tutorial helpful? Do you have any feedback for it? Are there any areas where you think this could be improved?</p> <p>Let me know either on the Klipper Discourse or in a Documentation Issue on Github.</p> <p>Thank you for your feedback!</p>"},{"location":"extras/extras-start/","title":"Start Writing Klippy Extras","text":"<p>While DynamicMacros makes Klipper macros much more powerful, sometimes a Klippy extra is required for more functionality. In this tutorial, you will learn how to develop a Klippy extra and test it using DynamicMacros.</p> <p>Info</p> <p>To write a Klipper extra, you should be fluent in Python.</p> Klipper vs Klippy <p>To limit confusion, I'm going to explain this here. \"Klipper\" is the name of the firmware running on your 3D printer. \"Klippy\" is the name of the software running on your Klipper Host (usually a Raspberry Pi). Klipper is written in C code, and Klippy is mostly written in Python.</p> <p>Start writing your first Klippy extra:</p> <p>Start </p>"},{"location":"features/delayed/","title":"Delayed GCode","text":"<p>Dynamic Macros supports a feature similar to <code>delayed_gcode</code>.</p>"},{"location":"features/delayed/#configuration","title":"Configuration","text":"<p>To configure a DynamicMacro to be run repeatedly/after a delay, update your macro as follows:</p> BeforeAfter <pre><code>[gcode_macro test]\ngcode:\n    RESPOND MSG=\"test\"\n</code></pre> <pre><code>[gcode_macro test]\ninitial_duration: 2 # Wait two seconds after Klipper starts to run this, and two seconds between repeats (if enabled)\nrepeat: true # true means repeat, false means don't repeat\ngcode:\n    RESPOND MSG=\"test\"\n</code></pre>"},{"location":"features/delayed/#parameters","title":"Parameters","text":"<p><code>initial_duration</code> specifies the delay after Klipper starts that the macro will be run, and the duration between repeats, if <code>repeat</code> is true.</p> <p><code>repeat</code> specifies whether or not to repeat the macro.</p>"},{"location":"features/python/","title":"Python","text":"<p>Dynamic Macros's most powerful feature allows you to run Python code directly from within a macro.</p>"},{"location":"features/python/#running-python-from-within-a-macro","title":"Running Python from within a Macro","text":"<p>Disclaimer</p> <p>This functionality allows Dynamic Macros to gain significant control over your printer and Klipper host. I am not responsible for whatever happens if you download a malicious macro.</p> <p>There are three main reasons why this could be helpful:</p> <ol> <li>Allowing for deeper control of Klipper and the Klipper host</li> <li>A learning bridge for creating Klipper plugins/extras</li> <li>A tool to help develop Klipper plugins/extras without restarting Klipper</li> </ol> <p>To run Python from within a Dynamic Macro, use either the <code>python()</code> utility function, or the <code>python_file()</code> utility function. The <code>python()</code> function accepts python code as a multiline string, and the <code>python_file()</code> function accepts a filename (relative to your <code>printer.cfg</code> folder).</p> <p>Tip</p> <p>When using the <code>python()</code> utiltiy function, Jinja2 (which converts the macro to GCode) may throw errors during parsing. If you are getting errors, it is recommended to switch to <code>python_file()</code>.</p> <p>Here are a few examples:</p>"},{"location":"features/python/#python-math","title":"Python Math","text":"macros.cfg<pre><code>[gcode_macro MATH]\ngcode:\n    {% set value = python(\"\"\"\n    a = kwargs['a']\n    b = kwargs['b']\n    c = a + b\n    output(c)\n    \"\"\", a=1, b=2) %}\n    RESPOND MSG={value}\n</code></pre>"},{"location":"features/python/#python-file-running-gcode","title":"Python File Running GCode","text":"macros.cfg<pre><code>[gcode_macro PYFILE]\ngcode:\n    {% set value = python_file(\"test.py\") %}\n    RESPOND MSG={value}\n</code></pre> test.py<pre><code>print(\"Hello from Python!\")\ngcode(\"G28\\nG1 X100 Y100 Z100 F1200\")\noutput(\"GCode Executed\")\n</code></pre>"},{"location":"features/receivingvariables/","title":"Receiving Variable Updates","text":"<p>Unlike normal <code>gcode_macro</code>s, Dynamic Macros supports receiving variable updates within the same macro. For example, the following macro will show the same output in both <code>M117</code>s:</p> <pre><code>[gcode_macro STATIC_MOVE]\ngcode:\n  G28\n  M117 Before: {printer.toolhead.position.z}\n  # Above displays position before macro run\n  G90\n  G1 Z20\n  M117 After: {printer.toolhead.position.z}\n  # Above displays same position\n</code></pre> <p>However, this macro will show different outputs based on the current Z position of the toolhead:</p> <pre><code>[gcode_macro DYNAMIC_MOVE]\ngcode:\n  G28\n\n\n  M117 Before: {printer.toolhead.position.z}\n  # Above displays position after G28\n  G90\n  G1 Z20\n\n\n  M117 After: {printer.toolhead.position.z}\n  # Above displays position after G1\n</code></pre> <p>Notice the large whitespaces. Three newline characters (two blank lines) between code segments denotes a variable update. However, some variables won't be preserevd across the whitespace.</p> <pre><code>[gcode_macro VARIABLES]\ngcode:\n    {% set num = 10 %}\n    M117 {num}\n\n\n    M117 {num}\n    # Above line outputs nothing\n</code></pre> <p>You can use the <code>update()</code> function to preserve certain variables across the whitespaces:</p> <pre><code>[gcode_macro VARIABLES]\ngcode:\n    {% set num = update(\"num\", 10) %}\n    M117 {num}\n\n\n    M117 {num}\n    # Above line outputs 10\n</code></pre> <p>See Examples for examples.</p>"},{"location":"features/recursion/","title":"Recursion","text":"<p>Unlike normal <code>gcode_macro</code>s, Dynamic Macros supports recursion (allowing a macro to call itself). For more examples, see Examples</p>"},{"location":"features/utilities/","title":"Utility Functions","text":"<p>Dynamic Macros provides a few utility functions to make Dynamic Macros easier to write.</p>"},{"location":"features/utilities/#update","title":"update()","text":"<p>The <code>update()</code> function allows to save variables across whitespaces (see Receiving Variables for more information). Example:</p> <pre><code>[gcode_macro MY_MACRO]\ngcode:\n    {% set a = 10 %}\n    {% set b = update(\"b\", 20) %}\n    RESPOND MSG=\"A: {a}\" # 10\n    RESPOND MSG=\"B: {b}\" # 20\n\n\n    RESPOND MSG=\"A: {a}\" # \"\"\n    RESPOND MSG=\"B: {b}\" # 20\n</code></pre>"},{"location":"features/utilities/#get_macro_variables","title":"get_macro_variables()","text":"<p>The <code>get_macro_variables()</code> function allows to retrieve all the variables from another macro in one line of code. Example:</p> <pre><code>[gcode_macro MY_SETTINGS]\nvariable_a: 10\nvariable_b: 20\ngcode:\n    RESPOND MSG=\"settings\"\n\n[gcode_macro GET_SETTINGS]\ngcode:\n    {% set settings = get_macro_variables(\"MY_SETTINGS\") %}\n    RESPOND MSG=\"Settings: {settings}\"\n    RESPOND MSG=\"A: {settings.a}\"\n</code></pre>"},{"location":"features/utilities/#update_from_dict","title":"update_from_dict()","text":"<p>The <code>update_from_dict()</code> function allows for saving the output of <code>get_macro_variables()</code> (or other dictionaries) across the whitespaces when Receiving Variables. Example:</p> <pre><code>[gcode_macro MY_SETTINGS]\nvariable_a: 10\nvariable_b: 20\ngcode:\n    RESPOND MSG=\"settings\"\n\n[gcode_macro GET_SETTINGS]\ngcode:\n    {% set settings = get_macro_variables(\"MY_SETTINGS\") %}\n    {% set settings = update_from_dict(settings) %}\n\n\n    RESPOND MSG=\"A: {a}\" # 10\n    RESPOND MSG=\"B: {b}\" # 20\n</code></pre>"},{"location":"features/variables/","title":"Variables","text":"<p>Dynamic Macro variables work nearly the same way as standard <code>gcode_macro</code> variables. This guide covers the differences.</p>"},{"location":"features/variables/#set_dynamic_variable","title":"SET_DYNAMIC_VARIABLE","text":"<p>Instead of using <code>SET_GCODE_VARIABLE</code>, Dynamic Macros use <code>SET_DYNAMIC_VARIABLE</code> to update Dynamic Macro variables. Example (assuming <code>VAR_TEST</code> is defined from Utilities):</p> <pre><code>SET_DYNAMIC_VARIABLE MACRO=var_test VARIABLE=a VALUE=15\n</code></pre>"},{"location":"tutorial/","title":"Table of Contents","text":"<p>Follow this tutorial to learn how to create Dynamic Macros and to use its powerful features.</p>"},{"location":"tutorial/#standard-macros","title":"Standard Macros","text":"<p>Before writing macros, it's a good idea to learn how to write standard <code>gcode_macro</code>s. Here is an amazing guide on how to write standard macros.</p>"},{"location":"tutorial/#table-of-contents_1","title":"Table of Contents","text":"<ol> <li>Converting to Dynamic Macros</li> <li>Using Dynamic Macros Features</li> <li>Experimental Features</li> </ol>"},{"location":"tutorial/converting/","title":"Converting to Dynamic Macros","text":"<p>Follow this tutorial to convert your standard <code>gcode_macro</code> to a Dynamic Macro. </p>"},{"location":"tutorial/converting/#printercfg","title":"printer.cfg","text":"<p>First, remove the <code>include</code> line in your <code>printer.cfg</code> referencing the file your macros are in. For example, if your macros are in <code>macros.cfg</code>, remove the line:</p> <pre><code>[include macros.cfg]\n</code></pre> <p>from your <code>printer.cfg</code>.</p>"},{"location":"tutorial/converting/#dynamic-macros-configuration","title":"Dynamic Macros Configuration","text":"<p>Next, if you don't already have one, create a <code>[dynamicmacros]</code> config section in your <code>printer.cfg</code> and add your macro configuration to it:</p> printer.cfg<pre><code>[dynamicmacros]\nconfig_path: ~/printer_data/config # If you left your printer configuration path as the default, you don't need to specify this\nconfigs: macros.cfg # You can add more files to this list, separated by commas.\n</code></pre> KlipperScreen <p>If you convert your <code>LOAD_FILAMENT</code> and <code>UNLOAD_FILAMENT</code> macros to be dynamic, KlipperScreen may not recognize them and report an error. To fix this, add blank macros to your <code>printer.cfg</code>, before your <code>[dynamicmacros]</code> section. Example: printer.cfg<pre><code>[gcode_macro LOAD_FILAMENT]\ngcode:\n    M117 LOAD\n[gcode_macro UNLOAD_FILAMENT]\ngcode:\n    M117 UNLOAD\n</code></pre></p> Unknown config object 'gcode_macro' <p>If you are getting a \"Unknown config object 'gcode_macro'\" error after converting your macros to Dynamic Macros, move your <code>[dynamicmacros]</code> section to be after your <code>[virtual_sdcard]</code> section.</p> Nacro Names <p>Klipper has certain macro names reserved for core functionality. If you are experiencing errors, don't name your Dynamic Macros any of the following:</p> <ul> <li><code>PAUSE</code></li> <li><code>RESUME</code></li> <li><code>CANCEL_PRINT</code></li> </ul> <p>If you want to make those macros dynamic, first define them as a standard GCode macro:</p> <pre><code>[gcode_macro PAUSE]\ngcode:\n    DYNAMIC_PAUSE\n</code></pre> <p>Restart Klipper.</p> <p>That's it. Your macros are now Dynamic Macros.</p>"},{"location":"tutorial/experimental/","title":"Experimental Features","text":"<p>Warning</p> <p>The features on this page are experimental, and untested or only lightly tested. Proceed at your own risk.</p>"},{"location":"tutorial/usingfeatures/","title":"Using Dynamic Macros Features","text":"<p>Now that your macros are dynamic, you can use the powerful feature set of Dynamic Macros.</p>"},{"location":"tutorial/usingfeatures/#recursion","title":"Recursion","text":"<p>Recursion allows a macro to call itself, something standard GCode macros can't do. </p> <p>When using recursion, it's important to make sure your macro has an \"end case\". This is a case when the macro won't call itself again. Otherwise the macro will be stuck in an infinite loop and freeze Klipper.</p> <p>Here are a few examples of recursion:</p> Counting to 10<pre><code>[gcode_macro COUNT]\ngcode:\n    {% set num = params.NUM|default(1)|int %}\n    {% if num &lt;= 10 %}\n        RESPOND MSG={num}\n        COUNT NUM={num+1} # Count up 1\n    {% else %}\n        RESPOND MSG=\"Done Counting\"\n    {% endif %}\n</code></pre> Load to Filament Sensor<pre><code>[gcode_macro LOAD_TO_FSENSOR]\ngcode:\n    {% set val = printer[\"filament_sensor fsensor\"].filament_detected %}\n    {% if val == 0 %}\n        M83\n        G1 E50 F900 # Move filament 50mm forwards\n        RESPOND MSG=\"Waiting for fsensor\"\n        LOAD_TO_FSENSOR # Recursion\n    {% else %}\n        G1 E65 F900 # Move filament to nozzle\n        RESPOND MSG=\"Filament Loaded\"\n    {% endif %}\n</code></pre>"},{"location":"tutorial/usingfeatures/#receiving-variable-updates","title":"Receiving Variable Updates","text":"<p>Receiving variable updates allows Dynamic Macros to update variables without rerunning the macro. </p> <p>An example of this is getting the printer's position. A standard GCode macro will evaluate all the variables, then run the GCode. However, using three newlines (two blank lines) between code segments in Dynamic Macros will allow each segment to be evaluated at runtime, allowing for variable updates.</p>"},{"location":"tutorial/usingfeatures/#utility-functions","title":"Utility Functions","text":"<p>See the link above (the subtitle) for more information on utility functions.</p>"},{"location":"tutorial/usingfeatures/#python","title":"Python","text":"<p>Dynamic Macro's most powerful feature allows you to run Python code from within a macro. See the link above (the subtitle) for more information.</p>"},{"location":"tutorial/usingfeatures/#delayed_gcode","title":"delayed_gcode","text":"<p>Dynamic Macros supports a feature similar to <code>delayed_gcode</code>. See the link above (the subtitle) for more information.</p>"}]}