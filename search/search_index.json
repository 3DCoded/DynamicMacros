{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Klipper Dynamic Macros","text":"<p>Never restart Klipper again for simple macros.</p> <p>Klipper Dynamic Macros is an unofficial way to update macros without restarting Klipper, so you can update macros mid-print and see their results live. It also supports extra features that normal GCode Macros don't have.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Recursion</li> <li>Receiving Variables</li> <li>Utility Functions</li> <li>Variables</li> <li>Python</li> <li>Delayed GCode</li> </ul>"},{"location":"#how-normal-macros-work","title":"How Normal Macros Work","text":"<p>Your macros are written in a <code>.cfg</code> file, then included into your <code>printer.cfg</code>. When Klipper restarts, it parses these files and saves the macros internally (you can't change them without restarting Klipper). When a macro is called, the cached code is interpreted and run.</p>"},{"location":"#how-dynamic-macros-work","title":"How Dynamic Macros Work","text":"<p>Your macros are written in a <code>.cfg</code> file, then the relative path to that file is configured in a <code>[dynamicmacros]</code> config section. The config files are read and parsed every time you run the macro, allowing you to update macros without restarting Klipper.</p>"},{"location":"#get-started","title":"Get Started","text":"<p>Follow Setup to get started with Dynamic Macros.</p>"},{"location":"#planned-features","title":"Planned Features","text":"<p>See Development Status for the currently available features, and planned features.</p>"},{"location":"#examples","title":"Examples","text":"<p>See Example Macros for examples of Dynamic Macros.</p>"},{"location":"#more-projects","title":"More Projects","text":"<p>If you like this project, don't forget to give it a star! Also, check out the 3MS, a modular multimaterial system for Klipper!</p>"},{"location":"devstatus/","title":"Development Status","text":""},{"location":"devstatus/#features","title":"Features","text":"<ul> <li>Editing macros without restarting Klipper</li> <li>Accessing printer information from within Dynamic Macros</li> <li>Accessing parameters from within Dynamic Macros</li> <li>Adding new Dynamic Macros without restarting Klipper</li> <li>Removing existing Dynamic Macros without restarting Klipper</li> <li>Renaming Dynamic Macros without restarting Klipper</li> <li>Dynamic Macro descriptions</li> <li>Dynamic Macro variables</li> <li>Retrieving variables from other macros</li> <li>Support for <code>rename_existing</code></li> <li>Running Python from within a Dynamic Macro</li> <li>Dynamic <code>delayed_gcode</code> implementation</li> </ul>"},{"location":"devstatus/#planned-features","title":"Planned Features","text":"<p>A checkmark indicates a feature is experimental.</p> <ul> <li> Allow configuring multiple <code>dynamicmacros</code> config sections as clusters<ul> <li> Disable Python per-cluster</li> <li> Disable <code>printer</code> object per-cluster</li> </ul> </li> <li> Better error handling</li> <li> Klippy extras tutorial</li> </ul>"},{"location":"examples/","title":"Example Macros","text":"<p>This page will hold several different Dynamic Macro examples. Note that most of the examples here are specific to Dynamic Macros only.</p>"},{"location":"examples/#m900","title":"M900","text":"<p>Normal Macro</p> <p>In Marlin, M900 K is used to set pressure/linear advance. Now, you can use it in Klipper too:</p> <pre><code>[gcode_macro M900]\ndescription: Set Pressure Advance\ngcode:\n  {% set k = params.K|default(0)|float %}\n  {% if k &lt; 1 %}\n    SET_PRESSURE_ADVANCE ADVANCE={k}\n  {% endif %}\n</code></pre>"},{"location":"examples/#recursion","title":"Recursion","text":"<p>Dynamic Macro</p> <p>These are a few example Dynamic Macros to demonstrate the recursive functionality of Dynamic Macros.</p> Counting to 10<pre><code>[gcode_macro COUNT]\ngcode:\n    {% set num = params.NUM|default(1)|int %}\n    {% if num &lt;= 10 %}\n        RESPOND MSG={num}\n        COUNT NUM={num+1} # Count up 1\n    {% else %}\n        RESPOND MSG=\"Done Counting\"\n    {% endif %}\n</code></pre> Load to Filament Sensor<pre><code>[gcode_macro LOAD_TO_FSENSOR]\ngcode:\n    {% set val = printer[\"filament_sensor fsensor\"].filament_detected %}\n    {% if val == 0 %}\n        M83\n        G1 E50 F900 # Move filament 50mm forwards\n        RESPOND MSG=\"Waiting for fsensor\"\n        LOAD_TO_FSENSOR # Recursion\n    {% else %}\n        G1 E65 F900 # Move filament to nozzle\n        RESPOND MSG=\"Filament Loaded\"\n    {% endif %}\n</code></pre>"},{"location":"examples/#receiving-position-updates","title":"Receiving Position Updates","text":"<p>Dynamic Macro</p> <p>This is an example Dynamic Macro to demonstrate the ability to receive position updates from within the same macro.</p> <pre><code>[gcode_macro DYNAMIC_MOVE]\ngcode:\n  G28\n\n\n  M117 Before: {printer.toolhead.position.z}\n  # Above displays position after G28\n  G90\n  G1 Z20\n\n\n  M117 After: {printer.toolhead.position.z}\n  # Above displays position after G1\n</code></pre>"},{"location":"examples/#preserving-variables","title":"Preserving Variables","text":"<p>Dynamic Macro</p> <p>This is an example of how to preserve variables across triple-newlines in Dynamic Macros.</p> <pre><code>[gcode_macro VARIABLES]\ngcode:\n    {% set num = update(\"num\", 10) %}\n    M117 {num}\n\n\n    M117 {num}\n    # Above line outputs 10\n</code></pre>"},{"location":"setup/","title":"Setup","text":"<p>Follow this guide to setup and confiure Dynamic Macros.</p>"},{"location":"setup/#install","title":"Install","text":"<p>Run in your terminal:</p> <pre><code>cd ~\ngit clone https://github.com/3DCoded/DynamicMacros\ncd DynamicMacros\nsh install.sh\nsudo service klipper restart\n</code></pre> <p>Add to your <code>moonraker.conf</code>:</p> moonraker.conf<pre><code># DynamicMacros Update Manager\n[update_manager DynamicMacros]\ntype: git_repo\npath: ~/DynamicMacros\norigin: https://github.com/3DCoded/DynamicMacros.git\nprimary_branch: main\nis_system_service: False\ninstall_script: install.sh\n</code></pre>"},{"location":"setup/#updating","title":"Updating","text":"<p>First, update via Moonraker's update manager. Then run in your terminal:</p> <pre><code>cd ~/DynamicMacros\nsh install.sh\nsudo service klipper restart\n</code></pre>"},{"location":"setup/#configuration","title":"Configuration","text":"<p>To configure Dynamic Macros, put in your <code>printer.cfg</code> (or a file included in it):</p> printer.cfg<pre><code>[dynamicmacros]\nconfigs: dynamic.cfg\n</code></pre> <p>Create a new file in the same folder as your <code>printer.cfg</code> called <code>dynamic.cfg</code>. In it, configure some macros like you normally would. Example:</p> dynamic.cfg<pre><code>[gcode_macro MYTEST]\ngcode:\n    M117 Hello world!\n\n[gcode_macro HEAT_HOTEND]\ngcode:\n    {% set temp = params.TEMP|int %}\n    M104 S{temp}\n</code></pre> <p>Restart Klipper.</p> <p>Info</p> <p>Updating the <code>[dynamicmacros]</code> config section requires a Klipper restart. The files listed in the <code>macros:</code> parameter must be present when Klipper restarts.</p>"},{"location":"setup/#testing","title":"Testing","text":"<p>If you run the command <code>MYTEST</code>, the output should be: <pre><code>Hello world!\n</code></pre></p> <p>If you runthe command <code>HEAT_HOTEND TEMP=200</code>, the hotend should start heating up. </p> <p>Next, edit the <code>MYTEST</code> macro to output something else, like <code>Test successful!</code></p> dynamic.cfg<pre><code>[gcode_macro MYTEST]\ngcode:\n    M117 Test successful!\n</code></pre> <p>Save the file, but do not restart Klipper.</p> <p>Run <code>MYTEST</code> again, and the output should be: <pre><code>Test successful!\n</code></pre></p>"},{"location":"setup/#features","title":"Features","text":"<ul> <li>Recursion</li> <li>Receiving Variable Updates</li> <li>Utility Functions</li> <li>Variables</li> </ul>"},{"location":"setup/#tutorial","title":"Tutorial","text":"<p>Follow the Tutorial.</p>"},{"location":"setup/#when-to-restart-klipper-or-reload-dynamic-macros","title":"When to Restart Klipper or Reload Dynamic Macros","text":"<p>Dynamic Macros provides a utility <code>DYNAMIC_MACRO</code> command to run macros manually, and to refresh the macros. Usage examples (assuming M900 is defined as a Dynamic Macro):</p> <pre><code>DYNAMIC_MACRO MACRO=M900 K=0.035\n</code></pre> <p>is the same as:</p> <pre><code>M900 K0.035\n</code></pre> <p>To refresh Dynamic Macros, just run <code>DYNAMIC_MACRO</code> with no parameters.</p> <p>A Klipper restart is required if:</p> <ul> <li>You changed the <code>description</code></li> <li>You changed the <code>initial_duration</code></li> <li>You changed the <code>repeat</code></li> </ul> <p>A <code>DYNAMIC_MACRO</code> refresh is required if:</p> <ul> <li>You created a new macro</li> <li>You renamed an existing macro</li> <li>You changed the contents of a macro</li> <li>You deleted an existing macro</li> </ul>"},{"location":"extras/extras-bettergreeter/","title":"BetterGreeter","text":"<p>Info</p> <p>This page is under construction.</p> <p>For this tutorial, we are going to improve on the greeter code used in Structure. </p> <p>For reference, the entire original greeter code is below:</p> Original Greeter <pre><code>class Greeter:\n    def __init__(self, config):\n        self.printer = config.get_printer()\n        self.reactor = self.printer.get_reactor()\n        self.gcode = self.printer.lookup_object('gcode')\n\n        self.message = config.get('message', 'Welcome to Klipper!')\n\n        self.gcode.register_command(\n            'GREET', self.cmd_GREET, desc=self.cmd_GREET_help)\n        self.printer.register_event_handler(\n            'klippy:ready', self._ready_handler)\n\n    def _ready_handler(self):\n        waketime = self.reactor.monotonic() + 1\n        self.reactor.register_timer(self._greet, waketime)\n\n    def _greet(self, eventtime=None):\n        self.gcode.respond_info(self.message)\n        return self.reactor.NEVER\n\n    cmd_GREET_help = \"Greet the user\"\n    def cmd_GREET(self, gcmd):\n        self._greet()\n\ndef load_config(config):\n    return Greeter(config)\n</code></pre>"},{"location":"extras/extras-bettergreeter/#goals","title":"Goals","text":"<p>For the <code>BetterGreeter</code>, we want the following features:</p> <ul> <li>Ability to have multiple different greetings</li> <li>Allow the user to choose if they want their greeting to display after Klipper starts, and if so, to set the delay</li> <li>Allow the user to set the message of the greeting</li> </ul> <p>Here's an example configuration:</p> better_greeter.cfg<pre><code>[greeting welcome]\nmessage: Welcome to Klipper!\ndelay: 1\n\n[greeting gcode]\nmessage: Upload some GCode!\ndelay: 2\n\n[greeting print_done]\nmessage: Print completed!\n</code></pre> <p>Here's the desired behavior (anything on the line of a <code>&gt;</code> is a user-typed command):</p> <pre><code>&gt; RESTART\nWelcome to Klipper! # (1)!\nUpload some GCode! # (2)!\n&gt; GREETING NAME=print_done\nPrint completed!\n</code></pre> <ol> <li>One second after <code>RESTART</code></li> <li>Two seconds after <code>RESTART</code></li> </ol>"},{"location":"extras/extras-bettergreeter/#creating-the-base-class","title":"Creating the Base Class","text":"<p>The first step of creating a Klippy extra is to make the base class and the config function: </p> <pre><code>class Greeting:\n    def __init__(self, config):\n        pass\n\n# (1)!\ndef load_config_prefix(config):\n    return Greeting(config)\n</code></pre> <ol> <li><code>load_config_prefix</code> is used here instead of <code>load_config</code> because there will be multiple <code>greeter</code> configuration sections.</li> </ol>"},{"location":"extras/extras-bettergreeter/#reading-the-configuration","title":"Reading the Configuration","text":"<p>The next step of our Klippy extra is to setup the class variables and read the parameters:</p> <pre><code>class Greeting:\n    def __init__(self, config):\n        self.printer = config.get_printer()\n        self.reactor = self.printer.get_reactor()\n        self.gcode = self.printer.lookup_object('gcode')\n        self.name = config.get_name().split()[1]\n\n        self.message = config.get('message', 'Welcome to Klipper!')\n        self.delay = config.get_int('delay', 0)\n</code></pre> <p>Here, the <code>printer</code>, <code>reactor</code>, <code>gcode</code>, and <code>message</code> variables are the same as in the previous Klippy extra. However, in this case, there are a couple new variables:</p> <ul> <li><code>name</code> is explained in the last section of Structure.</li> <li><code>delay</code> is read as an <code>int</code> from the <code>config</code> object, with default value <code>0</code>. The default value of <code>0</code> indicates it will not be run when Klippy starts.</li> </ul>"},{"location":"extras/extras-bettergreeter/#gcode-commands-and-event-handler","title":"GCode Commands and Event Handler","text":"<p>After reading the configuration variables, we need to setup the GCode commands and event handler:</p> <pre><code>class Greeting:\n    def __init__(self, config):\n        self.printer = config.get_printer()\n        self.reactor = self.printer.get_reactor()\n        self.gcode = self.printer.lookup_object('gcode')\n        self.name = config.get_name().split()[1]\n\n        self.message = config.get('message', 'Welcome to Klipper!')\n        self.delay = config.get_int('delay', 0)\n\n        #(1)!\n        self.gcode.register_mux_command(\n            'GREETING',\n            'NAME',\n            self.name,\n            self.cmd_GREETING,\n            desc=self.cmd_GREETING_help\n        )\n\n        if self.delay &gt; 0:\n            self.printer.register_event_handler(\n            'klippy:ready', self._ready_handler)\n</code></pre> <ol> <li><code>register_mux_command</code> is used here because there are multiple <code>greeting</code> configuration sections, and each should be called separately.</li> </ol> <p>Here, a few parts are similar to the example in Structure, but not identical. Let's start with the GCode command.</p> <p>In the Structure example, the GCode command was registered with:</p> <p><code>self.gcode.register_command('GREET', self.cmd_GREET, desc=self.cmd_GREET_help)</code></p> <p>In this new example, the GCode command is registered with:</p> <pre><code>self.gcode.register_mux_command(\n    'GREETING',\n    'NAME',\n    self.name,\n    self.cmd_GREETING,\n    desc=self.cmd_GREETING_help\n)\n</code></pre> <p>The difference here is that there can be multiple <code>greeting</code> configuration sections, and as a result, multiple <code>Greeting</code> objects. To call each one separately, <code>register_mux_command</code> is used, passing the following parameters:</p> <ul> <li>Macro name: <code>\"GREETING\"</code></li> <li>Parameter name: <code>\"NAME\"</code></li> <li>Parameter value: <code>self.name</code></li> <li>Function: <code>self.cmd_GREETING</code></li> <li>Description <code>self.cmd_GREETING_help</code></li> </ul> <p>Next, the <code>register_event_handler</code> is nearly identical to the Structure example, except in this case, it is run only <code>if self.delay &gt; 0</code>.</p>"},{"location":"extras/extras-start/","title":"Start Writing Klippy Extras","text":"<p>While DynamicMacros makes Klipper macros much more powerful, sometimes a Klippy extra is required for more functionality. In this tutorial, you will learn how to develop a Klippy extra and test it using DynamicMacros.</p> <p>Info</p> <p>To write a Klipper extra, you should be fluent in Python.</p> <p>Info</p> <p>This guide is still under construction</p> Klipper vs Klippy <p>To limit confusion, I'm going to explain this here. \"Klipper\" is the name of the firmware running on your 3D printer. \"Klippy\" is the name of the software running on your Klipper Host (usually a Raspberry Pi). Klipper is written in C code, and Klippy is mostly written in Python.</p> <p>Start writing your first Klippy extra:</p> <p>Start </p>"},{"location":"extras/extras-structure/","title":"Structure","text":"<p>Info</p> <p>This page is under construction.</p> <p>Before you start to write a Klippy extra, it is important to understand the structure of a Klippy extra. </p> <p>In Python, a Klippy extra is defined as a class, then referenced in a function at the end of the file. Example:</p> greeter.py<pre><code>class Greeter:\n...\n\ndef load_config(config):\n    return Greeter(config)\n</code></pre> <p>There are two functions that can be used at the end of a file:</p> <ul> <li><code>load_config_prefix</code>, allows for configurations like <code>[greeter mygreeter]</code></li> <li><code>load_config</code>, like in this example, allows for configurations like <code>[greeter]</code></li> </ul>"},{"location":"extras/extras-structure/#initializer","title":"Initializer","text":"<p>In the last line of the above code block, you can see that a <code>config</code> object is passed as a parameter to the <code>Greeter</code> object. The initializer of the <code>Greeter</code> class is shown below in sections:</p> Get printer objects and configuration options<pre><code>    def __init__(self, config):\n        self.printer = config.get_printer()\n        self.reactor = self.printer.get_reactor()\n        self.gcode = self.printer.lookup_object('gcode')\n\n        self.message = config.get('message', 'Welcome to Klipper!')\n</code></pre> <p>This section gets the <code>printer</code> object with <code>config.get_printer()</code>.</p> <p>It then gets the <code>gcode</code> object with <code>self.printer.lookup_object('gcode')</code>.</p> <p>Then, it gets the <code>reactor</code> object with <code>self.printer.get_reactor()</code>.</p> <p>After that, it reads the configuration to get the <code>message</code> parameter, specifying <code>'Welcome to Klipper!'</code> as the default, using <code>config.get('message', 'Welcome to Klipper!')</code>.</p> <p>The next part of the initializer:</p> Register GCode command and event handler<pre><code>        self.gcode.register_command(\n            'GREET', self.cmd_GREET, desc=self.cmd_GREET_help)\n        self.printer.register_event_handler(\n            'klippy:ready', self._ready_handler)\n</code></pre> <p>The <code>self.gcode</code> object is used here to register the <code>GREET</code> command: </p> <p><code>self.gcode.register_command('GREET', self.cmd_GREET, desc=self.cmd_GRRET_help)</code></p> <p>The <code>self.printer</code> object is then used to register an event handler to run when Klippy starts:</p> <p><code>self.printer.register_event_handler('klippy:ready', self._ready_handler)</code></p> Event handlers <p>Klipper supports the following event handlers for extras to use:</p> <ul> <li><code>\"klippy:ready\"</code></li> <li><code>\"klippy:firmware_restart\"</code></li> <li><code>\"klippy:disconnect\"</code></li> </ul> <p>The combined initializer is: greeter.py<pre><code>    def __init__(self, config):\n        self.printer = config.get_printer()\n        self.reactor = self.printer.get_reactor()\n        self.gcode = self.printer.lookup_object('gcode')\n\n        self.message = config.get('message', 'Welcome to Klipper!')\n\n        self.gcode.register_command(\n            'GREET', self.cmd_GREET, desc=self.cmd_GREET_help)\n        self.printer.register_event_handler(\n            'klippy:ready', self._ready_handler)\n</code></pre></p>"},{"location":"extras/extras-structure/#functions","title":"Functions","text":"<p>The next part of this Klippy extra is the class functions. This class has three functions aside from the initializer, two of which were mentioned in the <code>__init__</code> function:</p> <ul> <li><code>cmd_GREET</code></li> <li><code>_ready_handler</code></li> </ul> <p>This example will start with the <code>_ready_handler</code> function:</p> _ready_handler<pre><code>    def _ready_handler(self):\n        waketime = self.reactor.monotonic() + 1\n        self.reactor.register_timer(self._greet, waketime)\n</code></pre> <p>This event handler sets a timer for one second after Klippy starts to run <code>_greet()</code>. <code>self.reactor.monotonic()</code> represents the current time, and <code>+ 1</code> adds one second. <code>self.reactor.register_timer</code> registers <code>_greet()</code> to run when <code>waketime</code> occurs.</p> _greet()<pre><code>    def _greet(self, eventtime=None):\n        self.gcode.respond_info(self.message)\n        return self.reactor.NEVER\n</code></pre> <p>This function uses the <code>self.gcode</code> object declared in the initializer. Here, the <code>respond_info</code> command is used (similar to running <code>RESPOND MSG=\"\"</code>) to display <code>self.message</code>.</p> What is <code>eventtime</code>? <p>You may have noticed that <code>eventtime</code> is passed to the <code>_greet()</code> function. This is because when Klippy runs <code>_greet()</code> from the previous <code>register_timer</code>, it passes <code>eventtime</code> as a parameter. This is useful if you want a function to repeat itself after a specified interval. In this case, we only want it to run once, so <code>eventtime</code> is unused.</p> The <code>self.gcode</code> object <p>The <code>self.gcode</code> object has a few useful functions:</p> <ul> <li><code>register_command</code> (used in the initializer)</li> <li><code>register_mux_command</code> (explained later)</li> <li><code>respond_info</code> (used here)</li> <li><code>run_script_from_command</code> (runs the provided string as GCode. The provided string can be multiple lines long)</li> </ul> <p>Finally, the <code>cmd_GREET</code> function:</p> cmd_GREET<pre><code>    cmd_GREET_help = \"Greet the user\"\n    def cmd_GREET(self, gcmd):\n        self._greet()\n</code></pre> <p>Here, you can see the <code>cmd_GREET_help</code> is set to a string. Next, the <code>cmd_GREET</code> function takes in a <code>gcmd</code> parameter (unused). Finally, the <code>cmd_GREET</code> function calls <code>_greet()</code>.</p> The <code>gcmd</code> parameter <p>The <code>gcmd</code> parameter allows functions to receive parameters. For example, if <code>GREET REPEAT=3</code> was called, the <code>REPEAT</code> parameter could be read as follows:</p> <pre><code>repeat = gcmd.get_int('REPEAT', 1)\n</code></pre> <p>There are a few <code>get_</code> functions that can be used with the <code>gcmd</code> parameter:</p> <ul> <li><code>get</code> returns a <code>str</code></li> <li><code>get_int</code> returns an <code>int</code></li> <li><code>get_float</code> returns a <code>float</code></li> </ul> <p><code>gcmd</code> also has a <code>respond_info</code> function, similar to the <code>self.gcode.respond_info</code> function.</p> <p>The <code>repeat</code> variable can then be used:</p> <pre><code>for _ in range(repeat):\n    self._greet()\n</code></pre>"},{"location":"extras/extras-structure/#other-things","title":"Other Things","text":"<p>A few things that are good to know before moving on:</p> <ul> <li>If your Klippy extra uses <code>load_config_prefix</code>, instead of <code>load_config</code>, you can get the name of the configuration section (e.g. <code>[greeter first]</code> is named <code>first</code>) by using:      <pre><code>config.get_name().split()[1]\n</code></pre></li> <li>If you want to learn more about additional capabilities of Klippy extras, check out the built-in Klippy extras.</li> <li>For further explanation of topics on this page, open the dropdowns.</li> </ul> <p>Now, we can begin learning how to create Klippy extras:</p> <p>Start </p>"},{"location":"features/delayed/","title":"Delayed GCode","text":"<p>Dynamic Macros supports a feature similar to <code>delayed_gcode</code>.</p>"},{"location":"features/delayed/#configuration","title":"Configuration","text":"<p>To configure a DynamicMacro to be run repeatedly/after a delay, update your macro as follows:</p> BeforeAfter <pre><code>[gcode_macro test]\ngcode:\n    RESPOND MSG=\"test\"\n</code></pre> <pre><code>[gcode_macro test]\ninitial_duration: 2 # Wait two seconds after Klipper starts to run this, and two seconds between repeats (if enabled)\nrepeat: true # true means repeat, false means don't repeat\ngcode:\n    RESPOND MSG=\"test\"\n</code></pre>"},{"location":"features/delayed/#parameters","title":"Parameters","text":"<p><code>initial_duration</code> specifies the delay after Klipper starts that the macro will be run, and the duration between repeats, if <code>repeat</code> is true.</p> <p><code>repeat</code> specifies whether or not to repeat the macro.</p>"},{"location":"features/python/","title":"Python","text":"<p>Dynamic Macros's most powerful feature allows you to run Python code directly from within a macro.</p>"},{"location":"features/python/#running-python-from-within-a-macro","title":"Running Python from within a Macro","text":"<p>Disclaimer</p> <p>This functionality allows Dynamic Macros to gain significant control over your printer and Klipper host. I am not responsible for whatever happens if you download a malicious macro.</p> <p>There are three main reasons why this could be helpful:</p> <ol> <li>Allowing for deeper control of Klipper and the Klipper host</li> <li>A learning bridge for creating Klipper plugins/extras</li> <li>A tool to help develop Klipper plugins/extras without restarting Klipper</li> </ol> <p>To run Python from within a Dynamic Macro, use either the <code>python()</code> utility function, or the <code>python_file()</code> utility function. The <code>python()</code> function accepts python code as a multiline string, and the <code>python_file()</code> function accepts a filename (relative to your <code>printer.cfg</code> folder).</p> <p>Tip</p> <p>When using the <code>python()</code> utiltiy function, Jinja2 (which converts the macro to GCode) may throw errors during parsing. If you are getting errors, it is recommended to switch to <code>python_file()</code>.</p> <p>Here are a few examples:</p>"},{"location":"features/python/#python-math","title":"Python Math","text":"macros.cfg<pre><code>[gcode_macro MATH]\ngcode:\n    {% set value = python(\"\"\"\n    a = kwargs['a']\n    b = kwargs['b']\n    c = a + b\n    output(c)\n    \"\"\", a=1, b=2) %}\n    RESPOND MSG={value}\n</code></pre>"},{"location":"features/python/#python-file-running-gcode","title":"Python File Running GCode","text":"macros.cfg<pre><code>[gcode_macro PYFILE]\ngcode:\n    {% set value = python_file(\"test.py\") %}\n    RESPOND MSG={value}\n</code></pre> test.py<pre><code>print(\"Hello from Python!\")\ngcode(\"G28\\nG1 X100 Y100 Z100 F1200\")\noutput(\"GCode Executed\")\n</code></pre>"},{"location":"features/receivingvariables/","title":"Receiving Variable Updates","text":"<p>Unlike normal <code>gcode_macro</code>s, Dynamic Macros supports receiving variable updates within the same macro. For example, the following macro will show the same output in both <code>M117</code>s:</p> <pre><code>[gcode_macro STATIC_MOVE]\ngcode:\n  G28\n  M117 Before: {printer.toolhead.position.z}\n  # Above displays position before macro run\n  G90\n  G1 Z20\n  M117 After: {printer.toolhead.position.z}\n  # Above displays same position\n</code></pre> <p>However, this macro will show different outputs based on the current Z position of the toolhead:</p> <pre><code>[gcode_macro DYNAMIC_MOVE]\ngcode:\n  G28\n\n\n  M117 Before: {printer.toolhead.position.z}\n  # Above displays position after G28\n  G90\n  G1 Z20\n\n\n  M117 After: {printer.toolhead.position.z}\n  # Above displays position after G1\n</code></pre> <p>Notice the large whitespaces. Three newline characters (two blank lines) between code segments denotes a variable update. However, some variables won't be preserevd across the whitespace.</p> <pre><code>[gcode_macro VARIABLES]\ngcode:\n    {% set num = 10 %}\n    M117 {num}\n\n\n    M117 {num}\n    # Above line outputs nothing\n</code></pre> <p>You can use the <code>update()</code> function to preserve certain variables across the whitespaces:</p> <pre><code>[gcode_macro VARIABLES]\ngcode:\n    {% set num = update(\"num\", 10) %}\n    M117 {num}\n\n\n    M117 {num}\n    # Above line outputs 10\n</code></pre> <p>See Examples for examples.</p>"},{"location":"features/recursion/","title":"Recursion","text":"<p>Unlike normal <code>gcode_macro</code>s, Dynamic Macros supports recursion (allowing a macro to call itself). For more examples, see Examples</p>"},{"location":"features/utilities/","title":"Utility Functions","text":"<p>Dynamic Macros provides a few utility functions to make Dynamic Macros easier to write.</p>"},{"location":"features/utilities/#update","title":"update()","text":"<p>The <code>update()</code> function allows to save variables across whitespaces (see Receiving Variables for more information). Example:</p> <pre><code>[gcode_macro MY_MACRO]\ngcode:\n    {% set a = 10 %}\n    {% set b = update(\"b\", 20) %}\n    RESPOND MSG=\"A: {a}\" # 10\n    RESPOND MSG=\"B: {b}\" # 20\n\n\n    RESPOND MSG=\"A: {a}\" # \"\"\n    RESPOND MSG=\"B: {b}\" # 20\n</code></pre>"},{"location":"features/utilities/#get_macro_variables","title":"get_macro_variables()","text":"<p>The <code>get_macro_variables()</code> function allows to retrieve all the variables from another macro in one line of code. Example:</p> <pre><code>[gcode_macro MY_SETTINGS]\nvariable_a: 10\nvariable_b: 20\ngcode:\n    RESPOND MSG=\"settings\"\n\n[gcode_macro GET_SETTINGS]\ngcode:\n    {% set settings = get_macro_variables(\"MY_SETTINGS\") %}\n    RESPOND MSG=\"Settings: {settings}\"\n    RESPOND MSG=\"A: {settings.a}\"\n</code></pre>"},{"location":"features/utilities/#update_from_dict","title":"update_from_dict()","text":"<p>The <code>update_from_dict()</code> function allows for saving the output of <code>get_macro_variables()</code> (or other dictionaries) across the whitespaces when Receiving Variables. Example:</p> <pre><code>[gcode_macro MY_SETTINGS]\nvariable_a: 10\nvariable_b: 20\ngcode:\n    RESPOND MSG=\"settings\"\n\n[gcode_macro GET_SETTINGS]\ngcode:\n    {% set settings = get_macro_variables(\"MY_SETTINGS\") %}\n    {% set settings = update_from_dict(settings) %}\n\n\n    RESPOND MSG=\"A: {a}\" # 10\n    RESPOND MSG=\"B: {b}\" # 20\n</code></pre>"},{"location":"features/variables/","title":"Variables","text":"<p>Dynamic Macro variables work nearly the same way as standard <code>gcode_macro</code> variables. This guide covers the differences.</p>"},{"location":"features/variables/#set_dynamic_variable","title":"SET_DYNAMIC_VARIABLE","text":"<p>Instead of using <code>SET_GCODE_VARIABLE</code>, Dynamic Macros use <code>SET_DYNAMIC_VARIABLE</code> to update Dynamic Macro variables. Example (assuming <code>VAR_TEST</code> is defined from Utilities):</p> <pre><code>SET_DYNAMIC_VARIABLE MACRO=var_test VARIABLE=a VALUE=15\n</code></pre>"},{"location":"tutorial/","title":"Table of Contents","text":"<p>Follow this tutorial to learn how to create Dynamic Macros and to use its powerful features.</p>"},{"location":"tutorial/#standard-macros","title":"Standard Macros","text":"<p>Before writing macros, it's a good idea to learn how to write standard <code>gcode_macro</code>s. Here is an amazing guide on how to write standard macros.</p>"},{"location":"tutorial/#table-of-contents_1","title":"Table of Contents","text":"<ol> <li>Converting to Dynamic Macros</li> <li>Using Dynamic Macros Features</li> <li>Experimental Features</li> </ol>"},{"location":"tutorial/converting/","title":"Converting to Dynamic Macros","text":"<p>Follow this tutorial to convert your standard <code>gcode_macro</code> to a Dynamic Macro. </p>"},{"location":"tutorial/converting/#printercfg","title":"printer.cfg","text":"<p>First, remove the <code>include</code> line in your <code>printer.cfg</code> referencing the file your macros are in. For example, if your macros are in <code>macros.cfg</code>, remove the line:</p> <pre><code>[include macros.cfg]\n</code></pre> <p>from your <code>printer.cfg</code>.</p>"},{"location":"tutorial/converting/#dynamic-macros-configuration","title":"Dynamic Macros Configuration","text":"<p>Next, if you don't already have one, create a <code>[dynamicmacros]</code> config section in your <code>printer.cfg</code> and add your macro configuration to it:</p> printer.cfg<pre><code>[dynamicmacros]\nconfigs: macros.cfg # You can add more files to this list, separated by commas.\n</code></pre> KlipperScreen <p>If you convert your <code>LOAD_FILAMENT</code> and <code>UNLOAD_FILAMENT</code> macros to be dynamic, KlipperScreen may not recognize them and report an error. To fix this, add blank macros to your <code>printer.cfg</code>, before your <code>[dynamicmacros]</code> section. Example: printer.cfg<pre><code>[gcode_macro LOAD_FILAMENT]\ngcode:\n    M117 LOAD\n[gcode_macro UNLOAD_FILAMENT]\ngcode:\n    M117 UNLOAD\n</code></pre></p> Unknown config object 'gcode_macro' <p>If you are getting a \"Unknown config object 'gcode_macro'\" error after converting your macros to Dynamic Macros, move your <code>[dynamicmacros]</code> section to be after your <code>[virtual_sdcard]</code> section.</p> Nacro Names <p>Klipper has certain macro names reserved for core functionality. If you are experiencing errors, don't name your Dynamic Macros any of the following:</p> <ul> <li><code>PAUSE</code></li> <li><code>RESUME</code></li> <li><code>CANCEL_PRINT</code></li> </ul> <p>If you want to make those macros dynamic, first define them as a standard GCode macro:</p> <pre><code>[gcode_macro PAUSE]\ngcode:\n    DYNAMIC_PAUSE\n</code></pre> <p>Restart Klipper.</p> <p>That's it. Your macros are now Dynamic Macros.</p>"},{"location":"tutorial/experimental/","title":"Experimental Features","text":"<p>Warning</p> <p>The features on this page are experimental, and untested or only lightly tested. Proceed at your own risk.</p>"},{"location":"tutorial/usingfeatures/","title":"Using Dynamic Macros Features","text":"<p>Now that your macros are dynamic, you can use the powerful feature set of Dynamic Macros.</p>"},{"location":"tutorial/usingfeatures/#recursion","title":"Recursion","text":"<p>Recursion allows a macro to call itself, something standard GCode macros can't do. </p> <p>When using recursion, it's important to make sure your macro has an \"end case\". This is a case when the macro won't call itself again. Otherwise the macro will be stuck in an infinite loop and freeze Klipper.</p> <p>Here are a few examples of recursion:</p> Counting to 10<pre><code>[gcode_macro COUNT]\ngcode:\n    {% set num = params.NUM|default(1)|int %}\n    {% if num &lt;= 10 %}\n        RESPOND MSG={num}\n        COUNT NUM={num+1} # Count up 1\n    {% else %}\n        RESPOND MSG=\"Done Counting\"\n    {% endif %}\n</code></pre> Load to Filament Sensor<pre><code>[gcode_macro LOAD_TO_FSENSOR]\ngcode:\n    {% set val = printer[\"filament_sensor fsensor\"].filament_detected %}\n    {% if val == 0 %}\n        M83\n        G1 E50 F900 # Move filament 50mm forwards\n        RESPOND MSG=\"Waiting for fsensor\"\n        LOAD_TO_FSENSOR # Recursion\n    {% else %}\n        G1 E65 F900 # Move filament to nozzle\n        RESPOND MSG=\"Filament Loaded\"\n    {% endif %}\n</code></pre>"},{"location":"tutorial/usingfeatures/#receiving-variable-updates","title":"Receiving Variable Updates","text":"<p>Receiving variable updates allows Dynamic Macros to update variables without rerunning the macro. </p> <p>An example of this is getting the printer's position. A standard GCode macro will evaluate all the variables, then run the GCode. However, using three newlines (two blank lines) between code segments in Dynamic Macros will allow each segment to be evaluated at runtime, allowing for variable updates.</p>"},{"location":"tutorial/usingfeatures/#utility-functions","title":"Utility Functions","text":"<p>See the link above (the subtitle) for more information on utility functions.</p>"},{"location":"tutorial/usingfeatures/#python","title":"Python","text":"<p>Dynamic Macro's most powerful feature allows you to run Python code from within a macro. See the link above (the subtitle) for more information.</p>"},{"location":"tutorial/usingfeatures/#delayed_gcode","title":"delayed_gcode","text":"<p>Dynamic Macros supports a feature similar to <code>delayed_gcode</code>. See the link above (the subtitle) for more information.</p>"}]}